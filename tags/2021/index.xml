<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2021 on Pratik Jagrut</title>
    <link>https://pratikjagrut.dev/tags/2021/</link>
    <description>Recent content in 2021 on Pratik Jagrut</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 29 Apr 2021 08:23:36 +0530</lastBuildDate><atom:link href="https://pratikjagrut.dev/tags/2021/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Git aliases</title>
      <link>https://pratikjagrut.dev/blog/git/aliases/</link>
      <pubDate>Thu, 29 Apr 2021 08:23:36 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/git/aliases/</guid>
      <description>Git is the most widely used Version Control System (VCS) or Source Code Management(SCM) software. It is a day-to-day go-to tool for many of the developers out there. And many developers use terminal/command line to operate it.
In the terminal we type git commands git &amp;lt;sub-command&amp;gt; &amp;lt;flag&amp;gt; it runs if it succeeds we&amp;rsquo;re happy. On day-to-day basis we mostly use repetitive commands like git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;, git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;, git commit and many other and sometimes we use prolonged commands like this one git log --graph --pretty=format:&#39;%Cred%h%Creset %Cgreen%cr%Creset -%C(yellow)%d%Creset %s %C(bold blue)[%cn]%Creset&#39; --abbrev-commit --date=relative which prints commit history in custom fashion.</description>
    </item>
    
    <item>
      <title>Interface Part-2</title>
      <link>https://pratikjagrut.dev/blog/golang/series/interface_part_2/</link>
      <pubDate>Sun, 25 Apr 2021 10:46:37 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/interface_part_2/</guid>
      <description>Type assertion Type assertion is used to get the underlying concrete value of the interface variable. i.(Type) this is the syntax of type assertion, where:
i -&amp;gt; interface variable
Type -&amp;gt; type that implements interface
Let&amp;rsquo;s see an example of type assertion.
package main import &amp;quot;fmt&amp;quot; type Person interface { info() string } type Student struct { name string } func (s Student) info() string { return fmt.Sprintf(&amp;quot;Student name is %s\n&amp;quot;, s.</description>
    </item>
    
    <item>
      <title>Interface Part-1</title>
      <link>https://pratikjagrut.dev/blog/golang/series/interface_part_1/</link>
      <pubDate>Sun, 07 Mar 2021 20:14:16 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/interface_part_1/</guid>
      <description>In Golang, an interface is a set of method signatures. When any type defines all the methods from an interface then that type implements the interface. So we can state that interface defines the behaviour of the object/type.
For example, an animal walks, eats and sleeps so we can have an interface Animal which declares the methods walk, eat and sleep and any animal e.g. Tiger, who walks, eats and sleeps so we say Tiger implements the animal interface.</description>
    </item>
    
    <item>
      <title>Structs part-2</title>
      <link>https://pratikjagrut.dev/blog/golang/series/structs_part_2/</link>
      <pubDate>Thu, 04 Mar 2021 21:53:38 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/structs_part_2/</guid>
      <description>Nested Structs Golang allows us to use struct as a field of another struct, this pattern is called nesting. A nested struct can be defined using the following syntax.
type struct1 struct{ // fields } type struct2 struct{ // fields s struct1 } Suppose we need to collect the data of a person, person&amp;rsquo;s name, age and address. In address, we need to collect the city and country of that person.</description>
    </item>
    
    <item>
      <title>Structs part-1</title>
      <link>https://pratikjagrut.dev/blog/golang/series/structs_part_1/</link>
      <pubDate>Thu, 04 Mar 2021 18:02:10 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/structs_part_1/</guid>
      <description>What is Struct? A struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique. From golang docs.
In simple words, a struct is a user-defined type that allows the collection of different types of elements. These elements are called fields. Structs can be used to keep certain data together.</description>
    </item>
    
    <item>
      <title>Pointers</title>
      <link>https://pratikjagrut.dev/blog/golang/series/pointers/</link>
      <pubDate>Fri, 26 Feb 2021 16:49:28 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/pointers/</guid>
      <description>The pointer is a special variable in Golang that stores the memory address of other variables.
Variables are used to store some type of data. All variables are assigned a particular memory where they store data and this memory has a memory address that is in hexadecimal format. The number that starts with 0x is hexadecimal like (0x14 which is equivalent to 20 in decimal). Golang allows us to store this memory address in variables but only pointers will understand that the stored value is pointing to some memory whereas other variables will treat it just as a value.</description>
    </item>
    
    <item>
      <title>Closures</title>
      <link>https://pratikjagrut.dev/blog/golang/series/closures/</link>
      <pubDate>Sun, 14 Feb 2021 19:08:25 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/closures/</guid>
      <description>Golang supports anonymous functions which are then used to form closure functions. Anonymous functions are function without any name. Before going any further read about anonymous function .
The closure is a special type of function value which references variable declared outside its body. The purpose of this function is to close over a variable of upper function to form a closure. The function may access and assign to the referenced variables; in this sense, the function is &amp;ldquo;bound&amp;rdquo; to the variables.</description>
    </item>
    
    <item>
      <title>Anonymous Function</title>
      <link>https://pratikjagrut.dev/blog/golang/series/anonymous_func/</link>
      <pubDate>Sun, 14 Feb 2021 19:07:57 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/anonymous_func/</guid>
      <description>The anonymous function is a feature in Golang which let us define a function without a name. This feature is also called a function literal. This is useful when you want an inline function or to form a closure.
Declaring the anonymous function The syntax is pretty straight forward and much similar to normal function.
func(parameter_list)(return_type){ return }() Parameter list and return type are optional.
() this will invoke the function as soon as it is defined.</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>https://pratikjagrut.dev/blog/golang/series/functions/</link>
      <pubDate>Tue, 12 Jan 2021 12:36:48 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/functions/</guid>
      <description>A function is a block of statements which performs a specific task. Functions is a well organized and reusable code. It improves the code readability, maintainability and testability. The general function is:
func function_name( [parameter list] ) [return_types] { body of the function } Declaring and calling functions The function is declared using func keyword.
func sayCheeze() { fmt.Println(&amp;quot;Cheeeeeeeeeeeeze&amp;quot;) } Calling the function is pretty easy.
sayCheeze() package main import &amp;quot;fmt&amp;quot; func sayCheeze() { fmt.</description>
    </item>
    
    <item>
      <title>Range</title>
      <link>https://pratikjagrut.dev/blog/golang/series/range/</link>
      <pubDate>Mon, 11 Jan 2021 23:41:28 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/range/</guid>
      <description>The range keyword is used to iterate over various data types. It is used in for loops and its return values are dependent on the data types over which we&amp;rsquo;re using range keyword.
Range over slice/array Range on Array and Slice returns the first value as an index and second value as an element located at that index.
package main import &amp;quot;fmt&amp;quot; func main() { nums := []int{1, 2, 3, 4, 5} for i, v := range nums { fmt.</description>
    </item>
    
    <item>
      <title>Maps</title>
      <link>https://pratikjagrut.dev/blog/golang/series/maps/</link>
      <pubDate>Sun, 10 Jan 2021 16:38:32 +0530</pubDate>
      
      <guid>https://pratikjagrut.dev/blog/golang/series/maps/</guid>
      <description>The map is a collection of key-value pairs. It is an implementation of a Hash Table, which provides Create/Add, Read, Update and Delete operations over the data. Collection of key-value pairs is unordered and each key is unique.
Declaration and initialization In general GO map looks like
map[KeyType]ValueType The KeyType could be anything that is comparable such as string, int etc. and ValueType could be anything, even it can be another map.</description>
    </item>
    
  </channel>
</rss>
