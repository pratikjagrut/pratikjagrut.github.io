[{
    "title": "Golang",
    "date": "",
    "description": "Index page",
    "body": "Contents Github Repo   \u0026emsp; \u0026#128279; Reference     Introduction and Installation  \u0026emsp;   First program in Go: Hello World  \u0026emsp;   Variables, data types and constants  \u0026emsp;   Looping Construct  \u0026emsp;   Conditional Statements  \u0026emsp;   Switch Statement  \u0026emsp;   Arrays and Slices  \u0026emsp;   Maps  \u0026emsp;   Range  \u0026emsp;  ",
    "ref": "/blog/golang/contents/"
  },{
    "title": "Range",
    "date": "",
    "description": "",
    "body": "The range keyword is used to iterate over various data types. It is used in for loops and its return values are dependent on the data types over which we\u0026rsquo;re using range keyword.\nRange over slice/array Range on Array and Slice returns the first value as an index and second value as an element located at that index.\nnums := []int{1, 2, 3, 4, 5} for i, v := range nums{ fmt.Printf(\u0026quot;Index :%d, value: %d\\n\u0026quot;, i, v) } Output:\nIndex :0, value: 1 Index :1, value: 2 Index :2, value: 3 Index :3, value: 4 Index :4, value: 5 Range over maps Range on Map returns the first value as a key and second value is a value associated with that key.\nm := map[string]int{\u0026quot;foo\u0026quot;: 0, \u0026quot;bar\u0026quot;: 1} for k, v:= range m { fmt.Printf(\u0026quot;Key :%s, value: %d\\n\u0026quot;, k, v) } Output:\nKey :foo, value: 0 Key :bar, value: 1 Range over a string Range on String returns the first value as an index and second value is rune int.\nstr := \u0026quot;golang\u0026quot; for i, s:= range str { fmt.Printf(\u0026quot;Index :%d, Rune value: %d\\n\u0026quot;, i, s) } Output:\nIndex :0, Rune value: 103 Index :1, Rune value: 111 Index :2, Rune value: 108 Index :3, Rune value: 97 Index :4, Rune value: 110 Index :5, Rune value: 103 Rune int value can be type cast string using string() method. e.g. string(103) == g\nRange over a channel Range on Channel returns only one value that is the value received from the channel.\nchannel := make(chan string, 2) channel \u0026lt;- \u0026quot;Hello\u0026quot; channel \u0026lt;- \u0026quot;World\u0026quot; close(channel) for v := range channel { fmt.Printf(\u0026quot;%s \u0026quot;, v) } *KEEP IN MIND*\nYou can not update the value in the range loop.\nnums := []int{1, 2, 3, 4, 5} fmt.Println(\u0026quot;Slice before range: \u0026quot;, nums) for _, v := range nums { v += 1 } fmt.Println(\u0026quot;Slice after range: \u0026quot;, nums)``` Output:\nSlice before range: [1 2 3 4 5] Slice after range: [1 2 3 4 5] In the above example, I try to increment all the values of the slice by 1 but the slice is unaffected. This is because the range loop copies the value from slice to local variable. So to update the slice we\u0026rsquo;ll need to use traditional way nums[i] += 1.\nYou can refer main.go file for examples\n ðŸ¡„ Maps   \u0026emsp; â€¢ Contents   \u0026emsp;  ðŸ¡†   \u0026emsp; -- Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/range/"
  },{
    "title": "Maps",
    "date": "",
    "description": "",
    "body": "The map is a collection of key-value pairs. It is an implementation of a Hash Table, which provides Create/Add, Read, Update and Delete operations over the data. Collection of key-value pairs is unordered and each key is unique.\nDeclaration and initialization In general GO map looks like\nmap[KeyType]ValueType The KeyType could be anything that is comparable such as string, int etc. and ValueType could be anything, even it can be another map.\nvar m map[int]string The above m is a map of int keys to string values.\nMaps are reference types such as slices. So uninitialized maps value is nil i.e the zero value of the map is nil. The nil map has no keys and we can not add any key to it because it does not point to any initialized map. Trying to add a key to nil map will throw panic: assignment to entry in nil map error.\nSo to get an initialized and ready to use map use make function.\nm = make(map[int]string) In the background make function assigns and initializes hash map data structure and returns map value which points to the hash map.\nMap literal\nn := map[string]int{\u0026quot;foo\u0026quot;: 0, \u0026quot;bar\u0026quot;: 1} Working with the maps Create a map using make function\nWe created a map m of string keys to int values.\nm := make(map[string]int) Add key-value pair\nThe syntax is fairly similar and easy to follow. Below key one is set to the value 1.\nm[\u0026quot;one\u0026quot;] = 1 Update operation has the same syntax\nm[\u0026quot;one\u0026quot;] = 2 Read a value\ni := m[\u0026quot;one\u0026quot;] If the key is not present then we get the value of type\u0026rsquo;s zero value.\nj := m[\u0026quot;two\u0026quot;] // Key not present // j == 0 We can check if the key is present in map with a two-value assignment statement.\nk, ok := m[\u0026quot;three\u0026quot;] _, ok := m[\u0026quot;three\u0026quot;] // Without retrieving the value. If the key is present ok == true if the key is not found ok == false.\nDelete value\nThe built-in delete function will delete the values from the map. It takes the map variable and key as an argument and it does not return anything. If the given key is not found it\u0026rsquo;ll not do anything.\ndelete(m, \u0026quot;one\u0026quot;) Iterating over the values in maps\nWe can use range to iterate.\nfor key, value := range m { fmt.Println(\u0026quot;Key:\u0026quot;, key, \u0026quot;Value:\u0026quot;, value) } While iterating over the map the iteration order is not specific, you may get different iteration order next time you iterate.\nYou can refer main.go file for examples\n ðŸ¡„ Arrays and Slices   \u0026emsp; â€¢ Contents   \u0026emsp; Range ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/maps/"
  },{
    "title": "Arrays and Slices",
    "date": "",
    "description": "",
    "body": "Array The array is a collection of the same type of element in a contiguous memory location. The array has fixed length i.e the number of elements to be stored is fixed before memory allocation.\nArray Declarations An array type definition specifies length and type of element. The array [n]T is of length n and type T.\n// This array can hold 3 integers. var i [3]int Arrays can be indexed in usual way, to access the n\u0026lt;sup\u0026gt;th\u0026lt;/sup\u0026gt; element we can do a[n].\ni[0] = 1 i[1] = 10 i[2] = 100 Array literal\nj := [3]string{\u0026quot;Go\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;fun\u0026quot;} We can make compiler to compute the length of an array.\nj := [...]string{\u0026quot;Go\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;fun\u0026quot;} In both cases, the type of j is [3]string.\nYou can refer main.go file for arrays examples\nSlices Arrays are a bit inflexible, so slices are widely used in GO. Slices are built on arrays giving it more flexibility, power and convenience.\nThe slice type is []T, specified without length and T is the element type.\nSlice formation A slice literal is like an array literal without the length.\ni := []int{1, 2, 3, 4, 5,} Creating a slice with make Slices can be created with the built-in make function; this is how you create dynamically-sized arrays.\nfunc make([]T, len, cap) []T Where,\n []T: Type of underlying array len: Length of the underlying array cap: Capacity of the underlying array, cap is optional  b := make([]int, 3, 5) If the capacity argument is omitted then capacity defaults to length.\na := make([]int, 5) Length and capacity The length of a slice is the number of elements it contains.\nThe capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.\nLength: len(s)\nCapacity: cap(s)\nCreating a slice from an array Slice can be formed by specifying 2 indices, high bound and low bound separated by a colon, s[low : high]. This selects a half-open range which includes the first element but excludes the last one.\nodds := [5]int{1, 3, 5, 7, 9} var o []int = odds[1:4] m := odds[1:4] We can skip low or high bound to use their defaults. For low bound default is 0 and for high bound default is length of an array.\na[:high], a[low:]\nTo create a slice of an entire array we can omit both high bound and low bound.\nodds := [5]int{1, 3, 5, 7, 9} o := odds[:] Slice internals A slice does not store any data, it just describes a section of an underlying array.\nA slice consists of a pointer to the array segment, length of an array segment and its capacity (the maximum length of the segment).\n ptr (*Ele)   Length (int)   Capacity (int)   Relation of array and slice When we create a slice we create a slice variable which stores the pointer, length and capacity of the underlying array. Slicing does not copy the elements, it creates a new slice variable pointing to the original array. Hence changing element of the slice will make those changes to an underlying array and all other slices which share the same underlying array will be affected.\nalphabet := [5]string{\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;D\u0026quot;} i := alphabet[0:3] j := alphabet[1:4] i[2] = \u0026quot;P\u0026quot; // This changes will affect alphabet, i ,j slices Append and copy functions Append func append(s []T, x ...T) []T The append function appends the data at the end of the slice. If the destination slice has enough capacity then it is re-sliced to accommodate the new element but if capacity is not enough then new underlying array is created and allocated.\na := make([]int, 1) // a == []int{0} a = append(a, 1, 2, 3) // a == []int{0, 1, 2, 3} Appending one slice to another\na := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;} b := []string{\u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;} a = append(a, b...) // a == []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;} Copy Slice can not grow beyond the capacity of the underlying array if it tries to grow will cause runtime panic error similar to index out of bounds error.\nnums := [3]int{1, 2, 3} // array n := nums[:] // slicing nums array n[3] = 4 // this will throw runtime error panic: runtime error: index out of range [3] with length 3 So to achieve the dynamic array we\u0026rsquo;ve to create a new bigger slice and copy the content from the old slice to a new slice.\nnums := [3]int{1, 2, 3} // array n := nums[:] // slicing nums array o := make([]int, len(n)+1) copy(o, n) o[3] = 4 The copy function takes destination slice and source slice as an argument and returns the number of elements copied.\nfunc copy(dst, src []T) int Examples Copy from one slice to another slice\nvar odds = make([]int, 3) n := copy(odds, []int{1, 3, 5}) // n == 3, odds == []int{1, 3, 5} Copy between same slice\nodds := []int{1, 3, 5} n := copy(odds, odds[1:]) // n == 2, s == []int{3, 5, 5} In this example, the values at index 0 and 1 are replaced by values at index 1 and 2.\nCopy from a string to a byte slice\nvar s = make([]byte, 5) copy(s, \u0026quot;Hello, world!\u0026quot;) // s == []byte(\u0026quot;Hello\u0026quot;) In this example, the slice s has a capacity of 5 elements so the only string Hello is copied to it.\nz := []int{1, 2, 3, 4, 5} z = append(z, 6, 7, 8) //1st arg is slice, and then can take any number of arg to append You can refer main.go file for slices examples\n ðŸ¡„ Switch Statement   \u0026emsp; â€¢ Contents   \u0026emsp; Maps ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/array_slice/"
  },{
    "title": "Switch",
    "date": "",
    "description": "",
    "body": "A switch statement is another way to write a sequence of if - else statements.\nGo\u0026rsquo;s switch is like the one in C and C++ except that it only runs the selected case, not all the cases that follows so we don\u0026rsquo;t need break statement here.\nswitch expression { case exp1: //Executes if expression matches exp1 case exp2: //Executes if expression matches exp2 default: //Executes if expression does not matches with any case } Switch evaluation order Switch cases evaluate cases from top to bottom and stops when a case succeeds.\nIn below example, it checks case \u0026quot;Linux\u0026quot;: if os matches with Linux then it stops at that case else go to the next case.\n//Prints which OS you're using switch os := runtime.GOOS; os { case \u0026quot;linux\u0026quot;: fmt.Println(\u0026quot;Linux.\u0026quot;) case \u0026quot;darwin\u0026quot;: fmt.Println(\u0026quot;OS X.\u0026quot;) default: fmt.Printf(\u0026quot;%s.\\n\u0026quot;, os) } Switch with NO condition Switch with no condition is like switch true. It is useful for writing log if-else-if ladder.\nt := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026quot;Good morning!\u0026quot;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026quot;Good afternoon.\u0026quot;) default: fmt.Println(\u0026quot;Good evening.\u0026quot;) } You can refer main.go file for examples\n ðŸ¡„ Conditional Statements   \u0026emsp; â€¢ Contents   \u0026emsp; Arrays and Slices ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/switch/"
  },{
    "title": "Conditional Statements",
    "date": "",
    "description": "",
    "body": "Conditional Statements are part of every programming language. They help us to decide which instruction is suppose to run when certain condition is met. e.g. If I\u0026rsquo;m hungry then I\u0026rsquo;ll eat else I\u0026rsquo;ll wait. e.g. If score is greater than 35%, you passed, else you failed.\nIf statement in Go if condition/expression { //instruction to be performed } Condition needs to be true to perform the given set of instructions.\npackage main import \u0026quot;fmt\u0026quot; func main(){ i := 10 if i % 2 == 0 { fmt.Printf(\u0026quot;%d is a even number\u0026quot;, i) } } If-Else statement in Go if condition/expression { //instruction to be performed } else { //instruction to be performed } If condition need to be false to perform instruction from else block.\npackage main import \u0026quot;fmt\u0026quot; func main(){ i := 11 if i % 2 == 0 { fmt.Printf(\u0026quot;%d is a even number\u0026quot;, i) } else { fmt.Printf(\u0026quot;%d is a odd number\u0026quot;, i) } } if-else-if ladder We can use multiple conditional statement at once which.\nif i == 0 { fmt.Println(\u0026quot;It's zero\u0026quot;) } else if i \u0026lt; 0 { fmt.Println(\u0026quot;Negative number\u0026quot;) } else { fmt.Println(\u0026quot;Positive number\u0026quot;) } If with a short statement if j := 10; j%2 == 0 { fmt.Println(\u0026quot;Even number\u0026quot;) } You can refer main.go file for examples\n ðŸ¡„ Looping Construct   \u0026emsp; â€¢ Contents   \u0026emsp; Switch Statement ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/if_else/"
  },{
    "title": "Looping Construct",
    "date": "",
    "description": "",
    "body": "Go has only one looping construct, the for loop.\nBasic for loop The basic for loop has three components separated by semicolons:\n init statement: i := 0 exec before 1st iteration condition expression: i \u0026lt; n eval on every interation post statement: i++ exec after each iteration  The expression is not surrounded by parentheses ( ) but the braces { } around set of instructions are required.\nfor i := 0; i \u0026lt; n; i++ { //business logic //set of instructions } Init and post statement are optional.\nfor ; i \u0026lt; n; { //business logic } For is also a while() loop for i \u0026lt; n { //business logic } Infinite loop for { //business logic } Example package main import \u0026quot;fmt\u0026quot; func main() { for i := 0; i \u0026lt; 5; i++ {fmt.Printf(\u0026quot;Iteration number: %d\\n\u0026quot;, i)} } go run main.go Iteration number: 0 Iteration number: 1 Iteration number: 2 Iteration number: 3 Iteration number: 4 You can refer main.go file for examples\n ðŸ¡„ Variables, data types and constants   \u0026emsp; â€¢ Contents   \u0026emsp; Conditional Statements ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/for_loop/"
  },{
    "title": "Variables, data types and constants",
    "date": "",
    "description": "",
    "body": "Variable Variable is a symbolic name given to the storage location which contains some value which can be changed at any time during the execution of the program. A variable must be defined with the type of data or value it is holding.\nData types There are several data types in Go.\nbool int uint float32 complex64 string int8 uint8 float64 complex128 byte int16 uint16 rune int32 uint32 error int64 uint64 Zero value In some programming languages variable holds a null or undefined value when not initialized, Go gives it a zero-value of its data type. A boolean variable if not initialized, gets the false value and an integer variable gets 0 value, string variable will get nil value.\nDeclaring a variable The var statement declares a list of variables. Type is at the last of the statement.\nvar varName dataType E.g.:\nvar i, j, k int var f float32 var u uint Variables with initializers\nWe can initialize variable while declaring.\nvar varName dataType = value var i int = 10 var s string = \u0026quot;hello\u0026quot; var ok bool = true We can omit the type of variable, it will take the type of initializers\nvar i = 42 // int var f = 3.142 // float64 var g = \u0026quot;hello\u0026quot; // string Short-hand declaration\nThis is the most commonly used variable declaration inside functions.\nvarName := value E.g.:\ni := 10 s := \u0026quot;hello\u0026quot; ok := true When declaring a variable without specifying it\u0026rsquo;s type the variable\u0026rsquo;s type is inferred from the value on the right-hand side.\nvar i int j := i // j is an int i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 Assign or Re-assign\nYou can assign or re-assign value to a declared variable as:\nvarName = value E.g.:\ni = 12 s = \u0026quot;world\u0026quot; ok = false Multiple variable declarations\nMultiple variables of the same type with the single var statement\nvar i, j, k int var x, y, z = 0.867 + 0.5i, 4.65, true Multiple variables of the different types with the single var statement\nvar ( i int = 10 s string = \u0026quot;hello\u0026quot; ok bool = true ) Constants Go supports constants of character, string, boolean, and numeric values. Constants are declared using const keyword.\nE.g:\nconst str string = \u0026quot;constants\u0026quot; Untyped and Typed\nConstants can be declared with or without a type in Go. If we are declaring literal constant, then we are declaring constants that are untyped and unnamed.\nE.g.:\nconst str string = \u0026quot;constants\u0026quot; //Typed constant const i = 10 //Untyped constant, literal declaration const f = 3.14 The constants on the LHS of the declaration are named constants and the literal values on the RHS are unnamed constants.\nTyped constants donâ€™t use the same type system as variables, they\u0026rsquo;ve their implementation for representing the values that we associate with them.\nIn the case of typed constant, the declared type is used to associate the typeâ€™s precision limitations or kind of constant.\nIn the case of untyped constant, the literal value will determine what kind/type the constant takes\nEvery GO compiler has the flexibility to implement constant as they wish, within the mandatory set of requirements.\nYou can refer main.go file for examples\n ðŸ¡„ First program in Go: Hello World   \u0026emsp; â€¢ Contents   \u0026emsp; Looping Construct ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/vdc/"
  },{
    "title": "Classic hello world program",
    "date": "",
    "description": "",
    "body": "First thing, packages In Go, source files are organized into system directories called packages, which enable code reusability. When you build reusable pieces of code, you will develop a package as a shared library. But when you develop executable programs, you will use the package main for making the package as an executable program. The package main tells the Go compiler that the package should compile as an executable program instead of a shared library.\npackage main Import The keyword import is used for importing a package into other packages. When you import packages, the Go compiler will look on the locations specified by the environment variable ROOT and PATH.\n// Single pkg/lib import import \u0026quot;fmt\u0026quot; // Multiple pkg/lib import import( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) Main function The main function in the package main will be the entry point of our executable program. When you build shared libraries, you will not have any main package and main function in the package.\nfunc main(){} Hello World package main import \u0026quot;fmt\u0026quot; func main() { fmt.Println(\u0026quot;Hello, World!\u0026quot;) } Save it as main.go or any-name-you-prefer.go\nTo run this program:\ngo run main.go Hello, World!  ðŸ¡„ Introduction and Installation   \u0026emsp; â€¢ Contents   \u0026emsp; Variables, data types and constants ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference   ",
    "ref": "/blog/golang/helloworld/"
  },{
    "title": "Go Introduction and Installation",
    "date": "",
    "description": "",
    "body": "Go is an open-source, statically typed, compiled programing language built by Google. It combines the simplest of both statically typed and dynamically typed languages and provides you with the proper mixture of efficiency and simple programming. It is primarily fitted to building fast, efficient, and reliable server-side or system applications.\nFollowing are some noted features of Go -\n Safety Concurrency Efficient Garbage Collection High-speed compilation Excellent Tooling support  Installing GO Go binary distributions are available for all major operating systems like Linux, Windows, and macOS. Itâ€™s easy to install Go from the binary distributions or you can try installing Go from source.\nLinux   Download Go for Linux from Goâ€™s official download page.\ntar -xvf go1.15.6.linux-amd64.tar.gz It will create a directory named go.\n  Move that dir to /usr/local where all other binaries reside.\nexport PATH=$PATH:/usr/local/go/bin   Custom Installation directory\nInstead of moving dir to /usr/local you can choose any other dir.\nmv go $HOME/ Then set this custom location to GOROOT environment variable.\nexport GOROOT=$HOME/go To make GOROOT permanent add it to .bashrc or .zshrc depending on which shell you are using or else your GOROOT will be unset once you end your terminal session or start a new terminal session.\n  MacOS X Install GO in MacOS using Homebrew.\nbrew install go Windows Download the Windows installer from Goâ€™s official download page. Open the installer and follow the on-screen instructions to install Go. By default, the installer installs Go in C:\\Go.\nOnce installed try go version to check the installation.\nGo Code organization  Note: After the introduction of Go modules in Go 1.11, its no longer required to store Go code in the Go workspace. You can create your Go project in any directory outside of GOPATH. You can refer to go docs on code organization. The following Go Code organization is still widely in use mostly because of its elegant organizing structure. \nWorkspace Go requires you to organize your code in a specific way -\nBy convention, all your Go code and the code must reside in a single workspace whose path is stored in the environment variable GOPATH.\nThe workspace dir is supposed to contain the following sub-dir:\n  src: contains Go source files.\nThe src directory typically contains many version control repositories containing one or more Go packages. Every Go source file belongs to a package. You generally create a new subdirectory inside your repository for every separate Go package. The tree for this looks like the following:\ngo â””â”€â”€ src â””â”€â”€ github.com â”œâ”€â”€ pratikjagrut â”‚ â””â”€â”€ go-tutorial â”‚ â””â”€â”€ helloworld â”‚ â””â”€â”€ main.go â””â”€â”€ user â””â”€â”€ project   bin: contains the executable binaries.\nThe Go tool builds and installs executable binaries to this directory.\n  pkg: contains Go package archives.\nAll the non-executable packages (shared libraries) are stored in this directory. This is typically imported and used inside other executable packages.\n  Setting GOPATH Linux and macOS mkdir $HOME/go_workspace export GOPATH=$HOME/go_workspace To make GOPATH permanent add it to .bashrc or .zshrc depending on which shell you are using or else your GOPATH will be unset once you end your terminal session or start a new terminal session.\nWindows System   Create the workspace folder at C:\\go-workspace.\n  Right-click on Start â†’ click Control Panel â†’ Select System and Security â†’ click on System.\n  From the menu on the left, select the Advanced system\u0026rsquo;s settings.\n  Click the Environment Variables button at the bottom.\n  Click New from the User variables section.\n  Type GOPATH into the Variable name field.\n  Type C:\\go-workspace into the Variable value field.\n  Click OK.\n  Note: GOPATH must be different than the path of your Go installation.\n â€¢ Contents   \u0026emsp; ðŸ¡† First program in Go: Hello World   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference   ",
    "ref": "/blog/golang/introduction/"
  },{
    "title": "Resume",
    "date": "",
    "description": "",
    "body": "PRATIK JAGRUT Bangalore, India  A computer science engineer, an open-source enthusiast and tech speaker with a passion for programming, eager to learn new technologies and desire to work in an environment which encourages learning. I\u0026rsquo;m a goal-oriented individual with a pleasant personality and a tenacity that knows no bounds.\n Experience   Red Hat / â€‹ Associate Software Engineer January 2019 - present, Bangalore, India  Working on a project called â€‹Service Binding Operator  which is an open source project. My primary focus is to test the quality of the product by adding automated tests and fixing bugs.    Red Hat / â€‹ Intern June 2018 - January 2019, Pune, India  Worked as an intern on project SSSD(System Security Services Daemon) which is a remote authentication client for Linux based systems. Primary worked to create an automated tests framework based on Pytest to add and write automated tests.    Sheng Li Telecom India Pvt Ltd / â€‹ Software Engineer Intern November 2017 - April 2018, Pune, India  Worked as a team lead and developer for the office automation project.     Open source Contribution   Tektoncd Cli , the Tekton Pipelines CLI project provides a CLI for interacting with Tekton!   Helm , the helm is a tool for managing packages of pre-configured Kubernetes resources.    Community contribution  Speaker at Paris Open source summit 2019, Speaker Kubernetes and Cloud-native Bangalore meetup. Member of the organizing committee of DevConf INDIA 2018.   Skills   Programming Languages\n Proficient in Golang and Python Prior experience: C++, PHP, TypeScript    Technologies\n Kubernetes, OpenShift, Podman, Linux, Git, Fedora, containers     Certifications   Red Hat Certified Specialist in OpenShift Administration      Red Hat Certified Specialist in OpenShift Application Development      Red Hat Certified Engineer      Red Hat Certified System Administrator     Education   G. H. Raisoni College of Engineering, Nagpur, Maharashtra, India BE. Computer science and Engineering, 2014 - 2018,\nCGPA: 8.73\n  Kulbhushan Jr. College, Aurangabad, Maharashtra, Indiaâ€‹ Higher School Secondary Certificate, 2012 - 2014\nPercentage: 79.08%*\n   Awards  Secured 1st position at e-Governance conference for best e-Governance Project model at 19th National e-Governance conference (01/2015). Secured 77th all India rank in IEEEXtreme 11.0, 24 hours coding competition.   Interests  Space science and quantum physics, philosophy, playing around open source projects, travelling, football and swimming.   Human languages  English Hindi Marathi   ",
    "ref": "/resume/"
  },{
    "title": "About Pratik",
    "date": "",
    "description": "",
    "body": "Pratik currently works at Red Hat as Associate Software Engineer since January 2019. He joined Red Hat as an intern just after graduating in 2018. He holds a Bachelor of Engineering degree in Computer Science.\nPratik is enthusiastic about Linux and opensource technologies. He\u0026rsquo;s fueled by his passion for understanding new technologies. He considers himself a â€˜forever student', eager to learn, grow and build his professional and personal life.\nPratik is also very enamoured of outdoor activities. He likes to play European football, swimming, trekking and travelling around the globe.\nClick here to know more about him.\nGithub  \u0026emsp; Twitter  \u0026emsp; Linkedin  \u0026emsp; Facebook  \u0026emsp; Email  ",
    "ref": "/about/"
  }]
