[{
    "title": "Git aliases",
    "date": "",
    "description": "",
    "body": "Git is the most widely used Version Control System (VCS) or Source Code Management(SCM) software. It is a day-to-day go-to tool for many of the developers out there. And many developers use terminal/command line to operate it.\nIn the terminal we type git commands git \u0026lt;sub-command\u0026gt; \u0026lt;flag\u0026gt; it runs if it succeeds we\u0026rsquo;re happy. On day-to-day basis we mostly use repetitive commands like git pull \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;, git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;, git commit and many other and sometimes we use prolonged commands like this one git log --graph --pretty=format:'%Cred%h%Creset %Cgreen%cr%Creset -%C(yellow)%d%Creset %s %C(bold blue)[%cn]%Creset' --abbrev-commit --date=relative which prints commit history in custom fashion.\nTyping those repetitive or lengthy, complex commands with too many arguments could be erroneous and could decrease our efficiency ensuing less productivity.\nIn this article, we\u0026rsquo;ll learn how to run Git command efficiently and develop a more productive Git workflow using Aliases.\nNOTE: The aliases in this article are my personal choice influenced by my day-to-day Git interaction.\nWhat is an alias? Aliases are short commands assigned to a particular command. It can be visualized as a shortcut for any command.\nCreating an alias serves some basic needs:\n  It helps to shorten the lengthy command and saves us from tedious, erroneous typing.\n  It saves us from memorizing complex commands.\n  Creates abridged commands for regularly used commands ensuing in an increase in productivity.\n  We can use two types of aliases for Git commands:\n Bash alias Git alias  We\u0026rsquo;ll look into both.\nBash Alias Defining a bash alias is a simple task. Below is a command for it.\nalias g='git' And done, we\u0026rsquo;ve g as an alias for the git command.\nBut this alias is not persistent as soon as you end the terminal session the alias is gone. To make it persistent we\u0026rsquo;ve to add this alias in .bashrc if you use the bash shell or .zshrc if you use zsh. These files are mostly located in you\u0026rsquo;re home directory.\nTo know what shell you\u0026rsquo;re using type echo\necho \u0026quot;$SHELL\u0026quot; /usr/bin/zsh For the git command, I\u0026rsquo;ve two bash aliases g and gt. Sometimes due to old habit, I tend to type git instead of g and while doing that sometimes I miss the i in git so to avoid throwing an error I added gt as an alias in .zshrc.\nalias g='git' alias gt='git' Git alias To define a git alias we use the git config command. We can define two types of aliases in Git.\n  Global aliases, which are stored in .gitconfig file which is mainly located in the home directory. These aliases are available to all git repositories present in the system. Command to define global alias:\ngit config --global alias.\u0026lt;alias_name\u0026gt; '\u0026lt;command\u0026gt;' or you can directly edit the .gitconfig file.   Local aliases, which are stored in .git/config file of the particular project. These aliases are not available to any other repository. Command to define local alias:\ngit config alias.\u0026lt;alias_name\u0026gt; '\u0026lt;command\u0026gt;' or you can directly edit the .git/config file.   Some useful git aliases   Git Status git status is a command which is used very frequently to see changed or untracked files.\ngit config --global alias.st 'status' So now instead of git status we can just type git st or g st if bash alias g=git is set. This is the benefit of using aliases, the whole command can be converted into few characters.\n$ g st On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean The git will store this alias in .gitconfig file under [alias] section as st = status.\n  Git Pull git pull \u0026lt;remote\u0026gt; \u0026lt;ref/branch\u0026gt; this command pulls the code from specified remote branch.\ngit config --global alias.pl 'pull' Now the pull command will be git pl \u0026lt;remote\u0026gt; \u0026lt;ref/branch\u0026gt;.\nWe can shorten it further depending on remote and branch.\ngit config --global alias.plo 'pull origin' Now the command git plo main is the same as git pull origin main.\nWe can create dedicated alias for git pull origin main\ngit config --global alias.plom 'pull origin main' Now the entire command is abridged, git plom.\n  Git Checkout git checkout Switch branches or restore working tree files.\ngit config --global alias.co 'checkout' Now we can use git co \u0026lt;branch\u0026gt; to checkout that branch.\nTo create new branch we use git checkout -b \u0026lt;new_branch\u0026gt; \u0026lt;start_point\u0026gt;\ngit config --global alias.cnb 'checkout -b' So now we can ues git cnb \u0026lt;new_branch\u0026gt; \u0026lt;start_point\u0026gt;\n  Git Branch git branch List, create, or delete branches\ngit config --global alias.br 'branch' $ git br * branch1 main   Git add git add \u0026lt;pathspec\u0026gt;... adds file contents to the index\ngit config --global alias.a 'add' The command will be git a \u0026lt;pathspec\u0026gt;...\nTo add all the files (changed + untracked) we can do git add ..\ngit config --global alias.aa 'add .' Now to add all files we can use git aa\n  Git commit After adding files to the index we use git commit to record changes to the repository. For git commit alias could be:\ngit config --global alias.ci 'commit' $ git ci [update.theme 89f083e] Update CR yaml 1 file changed, 1 insertion(+) create mode 100644 cr.yaml   Git push Once your changes are committed and you need to update the remote reference with new changes we use git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;\ngit config --global alias.p 'push' We can shorten it further depending on remote and branch.\ngit config --global alias.po 'push origin' Now the command git po main is the same as git push origin main.\nWe can create dedicated alias for git push origin main\ngit config --global alias.pom 'push origin main' Now the entire command is abridged, git pom.\n  Git log git log is one of the most important commands in git. It shows us the commit history. Now there are various ways of seeing commit history, depending on how we wanna see commit history we can use the flags.\nI usually use these three aliases for log.\nThis alias shows complete commit logs with the addition and deletion stats.\ngit config --global alias.lg 'log --stat' $ git lg commit 8b6ac3a9789002a2c578139c830f17b9e18b53f7 (HEAD -\u0026gt; git.aliases, origin/main, origin/HEAD, update.theme) Author: Pratik Jagrut \u0026lt;26519653+pratikjagrut@users.noreply.github.com\u0026gt; Date: Sat May 1 21:47:48 2021 +0530 Update public directory public | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) This alias draws a text-based graphical representation of the commit history printed in between commits with relative time.\ngit config --global alias.lgdr \u0026quot;log --graph --pretty=format:'%Cred%h%Creset %Cgreen%cr%Creset -%C(yellow)%d%Creset %s %C(bold blue)[%cn]%Creset' --abbrev-commit --date=relative\u0026quot; $ git lgdr * 8b6ac3a 6 hours ago - (HEAD -\u0026gt; git.aliases, origin/main, origin/HEAD, update.theme) Update public directory [Pratik Jagrut] * f47c1c6 6 hours ago - Update theme [Pratik Jagrut] This alias draws a text-based graphical representation of the commit history printed in between commits with a short format of the date.\ngit config --global alias.lgds \u0026quot;log --graph --pretty=format:'%Cred%h%Creset %Cgreen%cr%Creset -%C(yellow)%d%Creset %s %C(bold blue)[%cn]%Creset' --abbrev-commit --date=short $ git lgds * 8b6ac3a 2021-05-01 - (HEAD -\u0026gt; git.aliases, origin/main, origin/HEAD, update.theme) Update public directory [Pratik Jagrut] * f47c1c6 2021-05-01 - Update theme [Pratik Jagrut]   Here\u0026rsquo;s the .gitconfig file for all the above aliases.\n[alias] st = status pl = pull plo = pull origin plom = pull origin main co = checkout cnb = checkout -b br = branch a = add aa = add . ci = commit p = push po = push origin pom = push origin main lg = log --stat lgdr = log --graph --pretty=format:\u0026#39;%Cred%h%Creset %Cgreen%cr%Creset -%C(yellow)%d%Creset %s %C(bold blue)[%cn]%Creset\u0026#39; --abbrev-commit --date=relative lgds = log --graph --pretty=format:\u0026#39;%Cred%h%Creset %Cgreen%cd%Creset -%C(yellow)%d%Creset %s %C(bold blue)[%cn]%Creset\u0026#39; --abbrev-commit --date=shortThese were some of the aliases from my list, you can make more aliases for sub-commands like branch, remote, diff, config, etc\u0026hellip;\nConclusion Git aliases are a very useful feature. They help to improve the overall efficiency and productivity of git workflow. We can define as many aliases as we want, Git is too generous. It is always good to have aliases for regularly used and lengthy commands.\nThank you for reading this blog please give your feedback in the comment section below.\n",
    "ref": "/blog/git/aliases/"
  },{
    "title": "Golang",
    "date": "",
    "description": "Index page",
    "body": "Contents Github Repo   \u0026emsp; \u0026#128279; Reference     Introduction and Installation  \u0026emsp;   First program in Go: Hello World  \u0026emsp;   Variables, data types and constants  \u0026emsp;   Looping Construct  \u0026emsp;   Conditional Statements  \u0026emsp;   Switch Statement  \u0026emsp;   Arrays and Slices  \u0026emsp;   Maps  \u0026emsp;   Range  \u0026emsp;   Functions  \u0026emsp;   Anonymous Function  \u0026emsp;   Closures  \u0026emsp;   Pointers  \u0026emsp;   Structs Part-1  \u0026emsp;   Structs Part-2  \u0026emsp;   Interface Part-1  \u0026emsp;   Interface Part-2  \u0026emsp;  ",
    "ref": "/blog/golang/series/contents/"
  },{
    "title": "Interface Part-2",
    "date": "",
    "description": "",
    "body": "Type assertion Type assertion is used to get the underlying concrete value of the interface variable. i.(Type) this is the syntax of type assertion, where:\ni -\u0026gt; interface variable\nType -\u0026gt; type that implements interface\nLet\u0026rsquo;s see an example of type assertion.\npackage main import \u0026quot;fmt\u0026quot; type Person interface { info() string } type Student struct { name string } func (s Student) info() string { return fmt.Sprintf(\u0026quot;Student name is %s\\n\u0026quot;, s.name) } func main() { s := Student{ name: \u0026quot;Barry Allen\u0026quot;, } var p Person = s name := p.(Student) fmt.Println(name) } {Barry Allen} Run this code in Go Playground\nIn the above example, we create a Person interface which is then implicitly implemented by the Student struct by implementing the info method. var p Person = s this statement creates interface variable p and assign Student struct type variable s to it. name := p.(Student) this statement extracts the concrete value of type Student and assign it to the name variable.\nIn the above program, type Student implements the Person interface hence p.(Student) can hold the concrete value of type Student. But if Type from i.(Type) does not implement the interface then Go will throw a compilation error. Below is an illustrative example.\npackage main import \u0026quot;fmt\u0026quot; type Person interface { info() string } type Student struct { name string } func main() { var p Person name := p.(Student) fmt.Println(name) } ./prog.go:15:11: impossible type assertion: Student does not implement Person (missing info method) Run this code in Go Playground\nIf the Type implements the interface but the concrete value of that type is not available then Go will panic in runtime.\npackage main import \u0026quot;fmt\u0026quot; type Person interface { info() string } type Student struct { name string } func (s Student) info() string { return fmt.Sprintf(\u0026quot;Student name is %s\\n\u0026quot;, s.name) } func main() { var p Person name := p.(Student) fmt.Println(name) } panic: interface conversion: main.Person is nil, not main.Student goroutine 1 [running]: main.main() /tmp/sandbox657831697/prog.go:19 +0x45 Run this code in Go Playground\nSimilarly, if the concrete type of interface variable does not match with Type of i.(Type) then Go will panic in runtime.\npackage main import \u0026quot;fmt\u0026quot; type Person interface { info() string } type Student struct { name string } func (s Student) info() string { return fmt.Sprintf(\u0026quot;Student name is %s\\n\u0026quot;, s.name) } type Teacher struct { name string } func (s Teacher) info() string { return fmt.Sprintf(\u0026quot;Teacher name is %s\\n\u0026quot;, s.name) } func main() { t := Teacher{ name: \u0026quot;Richard Feynman\u0026quot;, } var p Person = t name := p.(Student) fmt.Println(name) } panic: interface conversion: main.Person is main.Teacher, not main.Student goroutine 1 [running]: main.main() /tmp/sandbox133075599/prog.go:30 +0x45 Run this code in Go Playground\nTo avoid the above panic errors Go has another way for type assertion.\nvalue, ok := i.(Type)\nIn the above syntax, Ok is a boolean variable. It will be false if i.(Type) has no concrete value and vice versa.\npackage main import \u0026quot;fmt\u0026quot; type Person interface { info() string } type Student struct { name string } func (s Student) info() string { return fmt.Sprintf(\u0026quot;Student name is %s\\n\u0026quot;, s.name) } type Teacher struct { name string } func (s Teacher) info() string { return fmt.Sprintf(\u0026quot;Teacher name is %s\\n\u0026quot;, s.name) } func main() { var p Person name, ok := p.(Student) fmt.Println(name, ok) t := Teacher{ name: \u0026quot;Richard Feynman\u0026quot;, } var p1 Person = t name, ok = p1.(Student) fmt.Println(name, ok) } {} false {} false Run this code in Go Playground\nType switch Type switch is similar to switch case statement where type switch compares the concrete type of an interface against types specified in cases. Below is the syntax of the type switch:\nswitch i.(type) { case float32: // Something to do case int: // Logic default: // Default logic } Here i.(type) syntax is fairly similar to type assertion syntax, where i is interface but instead of value type we use keyword type.\npackage main import ( \u0026quot;fmt\u0026quot; ) func guessType(i interface{}) { switch i.(type) { case string: fmt.Println(\u0026quot;It is string\u0026quot;) case int: fmt.Println(\u0026quot;It is Int\u0026quot;) case bool: fmt.Println(\u0026quot;It is boolean\u0026quot;) default: fmt.Println(\u0026quot;IDK\u0026quot;) } } func main() { guessType(10) guessType(\u0026quot;Hello\u0026quot;) guessType(true) guessType(10.11) } It is Int It is string It is boolean IDK Run this code in Go Playground\nIn the above example, we\u0026rsquo;re passing an empty interface as an argument to function. The empty interface is implemented by all the type so we can pass any type of parameter while calling that function.\ni.(type) evaluates the concrete type of an interface and then a matching case is executed if none of the cases is matched then the default case is executed.\nImplementing interfaces using pointer receivers vs value receivers In Golang methods can have both pointer or value as a receiver which restricts the accessibility of methods only to the type of its receiver. Methods from an interface can also pointer or value as a receiver in their implementation.\nImplementing interface with value receiver\npackage main import ( \u0026quot;fmt\u0026quot; ) type Car interface { information() } type Ferrari struct { name string colour string } func (f Ferrari) information() { fmt.Printf(\u0026quot;Name of the car: %s\\n\u0026quot;, f.name) fmt.Printf(\u0026quot;Colour of the car: %s\\n\u0026quot;, f.colour) fmt.Println() } func main() { var c1 Car f := Ferrari{ name: \u0026quot;SF90 STRADALE\u0026quot;, colour: \u0026quot;ROSSO CORSA\u0026quot;, } c1 = f c1.information() } Name of the car: SF90 STRADALE Colour of the car: ROSSO CORSA Run this code in Go Playground\nIn the above code, type Ferrari is implementing method information from an interface Car with a value receiver and in the main function, we\u0026rsquo;re assigning variable f of struct Ferrari to variable c1 of an interface Car and then calling information method using interface variable.\nImplementing interface with pointer receiver\npackage main import ( \u0026quot;fmt\u0026quot; ) type Car interface { information() } type Porsche struct { name string colour string } func (p *Porsche) information() { fmt.Printf(\u0026quot;Name of the car: %s\\n\u0026quot;, p.name) fmt.Printf(\u0026quot;Colour of the car: %s\\n\u0026quot;, p.colour) fmt.Println() } func main() { p := \u0026amp;Porsche{ name: \u0026quot;718 SPYDER\u0026quot;, colour: \u0026quot;BLACK\u0026quot;, } var c2 Car = p c2.information() } Name of the car: 718 SPYDER Colour of the car: BLACK Run this code in Go Playground\nIn the above code, type Porsche is implementing method information from an interface Car with a pointer receiver and in the main function we\u0026rsquo;re assigning variable pointer p of struct Porsche to variable c2 of an interface Car and then calling information method using interface variable.\nIn Golang, a method with value receiver or pointer receiver can be called on either value or pointer. It means if you\u0026rsquo;re implementing a method with a value receiver then you can use a value or pointer of that type to call that method.\nBut in the case of an interface does this phenomenon work?\nCalling method with value receiver on pointer type\nIn the below code, we implement the method information with value receiver and call it on pointer type.\npackage main import ( \u0026quot;fmt\u0026quot; ) type Car interface { information() } type Ferrari struct { name string colour string } func (f Ferrari) information() { fmt.Printf(\u0026quot;Name of the car: %s\\n\u0026quot;, f.name) fmt.Printf(\u0026quot;Colour of the car: %s\\n\u0026quot;, f.colour) fmt.Println() } func main() { var c Car f1 := \u0026amp;Ferrari{ name: \u0026quot;SF90 STRADALE\u0026quot;, colour: \u0026quot;ROSSO CORSA\u0026quot;, } c = f1 c.information() } Name of the car: SF90 STRADALE Colour of the car: ROSSO CORSA Run this code in Go Playground\nIn the above code, the pointer to value conversion is done by Golang implicitly. It is valid to call a method with value type on any value or anything whose value can be dereferenced.\nCalling method with pointer receiver on value type\nIn the below code, we implement the method information with pointer receiver and call it on the value type.\npackage main import ( \u0026quot;fmt\u0026quot; ) type Car interface { information() } type Porsche struct { name string colour string } func (p *Porsche) information() { fmt.Printf(\u0026quot;Name of the car: %s\\n\u0026quot;, p.name) fmt.Printf(\u0026quot;Colour of the car: %s\\n\u0026quot;, p.colour) fmt.Println() } func main() { var c Car p := Porsche{ name: \u0026quot;718 SPYDER\u0026quot;, colour: \u0026quot;BLACK\u0026quot;, } c = p c.information() } ./prog.go:29:4: cannot use p (type Porsche) as type Car in assignment: Porsche does not implement Car (information method has pointer receiver) Run this code in Go Playground\nIn the above code, we\u0026rsquo;re implementing the information method using pointer receiver and then calling it on value type instead of a pointer, and we\u0026rsquo;re getting compilation error. So what\u0026rsquo;s happening?\nIf we look at the implementation of the information method it has a pointer receiver and we\u0026rsquo;re calling it on p which is a value type and does not implement the Car interface. Hence we see the compilation error.\nBut in Golang, the method with value receiver or pointer receiver can be called on either value or pointer then why is this failing here?\nThis is because: it is completely valid to call the pointer receiver method on a pointer or on anything value whose address can be acquired that value which is addressable. In this case, the value type is assigned to the interface variable which is now a concrete value of the interface whose address can not be obtained and hence we get that compilation error.\nNote: If we call a method directly with struct variable then this issue will not occur.\nComparing interface\u0026rsquo;s variables The two interface variables are comparable only if the concrete value and concrete type are comparable. Interface variables can be compared with == and != operators.\nIf the concrete types or concrete values are not the same then the interface variables are not equal. If the concrete types or concrete values are the same then the interface variables are equal. Variables of an empty interface are always equal. Read more on Golang comparison operators.\npackage main import \u0026quot;fmt\u0026quot; type Int int func (i Int) String() string { return fmt.Sprintf(\u0026quot;Value of Int is %d\u0026quot;, i) } type Float float32 func (f Float) String() string { return fmt.Sprintf(\u0026quot;Value of Float is %f\u0026quot;, f) } func main() { var i Int = 10 var f Float = 5.5 var v1 fmt.Stringer = i var v2 fmt.Stringer = f fmt.Println(v1 == v2) // false, because concrete types are not same var i1 Int = 6 var v3 fmt.Stringer = i1 fmt.Println(v1 == v3) // false, because concrete values are not same var f2 Float = 5.5 var v4 fmt.Stringer = f2 fmt.Println(v2 == v4) // true var m, n interface{} fmt.Println(m == n) // true } Run this code in Go Playground\nSome good resources to read Go Data Structures: Interfaces by Russ Cox\nThe Laws of Reflection by Rob Pike\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Interface Part-1   \u0026emsp; • Contents   \u0026emsp;  🡆   \u0026emsp; -- Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/interface_part_2/"
  },{
    "title": "Interface Part-1",
    "date": "",
    "description": "",
    "body": "In Golang, an interface is a set of method signatures. When any type defines all the methods from an interface then that type implements the interface. So we can state that interface defines the behaviour of the object/type.\nFor example, an animal walks, eats and sleeps so we can have an interface Animal which declares the methods walk, eat and sleep and any animal e.g. Tiger, who walks, eats and sleeps so we say Tiger implements the animal interface.\nAnother example could be of shapes, any shape has an area and perimeter. So the Shape interface can declare area and perimeter methods and any shape such as rectangle or triangle can implement a shape interface.\nIt is much similar to the OOP world\u0026rsquo;s interface, where the interface specifies the methods and type decides how to implement them. In OOP programming we might have to use the implement keyword to explicitly implement the interface, but in Golang, if a type defines all the method from an interface then it implicitly implements interface.\nDeclaring and Implementing Interface To declare an interface in Golang we use the type and interface keyword. Below is a syntax:\ntype InterfaceName interface { // Method declaration } Stringer interface is declared in the fmt package, which has a signature of the only one method String.\nfmt.Stringer doc\ntype Stringer interface { String() string } To implement a particular interface a type needs to implement all the methods with exact name and signature defined in that interface. Interfaces in Go are implicitly implemented.\nBelow is an implementation of the fmt.Stringer interface from the standard library.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int address Address } type Address struct { city, country string pincode int } func (p Person) String() string { return fmt.Sprintf(\u0026quot;My name is '%s', I'm '%d' years old, I love in '%s', '%s'\u0026quot;, p.name, p.age, p.address.city, p.address.country) } func main() { person := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, address: Address{ city: \u0026quot;London\u0026quot;, pincode: 123456, country: \u0026quot;UK\u0026quot;, }, } address := Address{ city: \u0026quot;London\u0026quot;, country: \u0026quot;UK\u0026quot;, pincode: 123456, } fmt.Println(person) fmt.Println(address) } My name is 'James Bond', I'm '34' years old, I love in 'London', 'UK' {London UK 123456} Run this code in Go Playground\nIn the above example, we\u0026rsquo;ve two structs one is Person and the other one is Address and only the Person struct implements the Stringer interface by implementing the String() method because of which we could print the custom string format output.\nNotice the output, the person variable has its custom string and the address variable prints output in curly braces.\nOnce a type implements an interface then the method implemented by that type can also be called using interface variable.\npackage main import ( \u0026quot;fmt\u0026quot; ) type Shape interface { Area() } type Square struct { side int } func (s Square) Area() { fmt.Printf(\u0026quot;Area of the square is %d\\n\u0026quot;, s.side*s.side) } func main() { sq := Square{ side: 10, } var sh Shape = sq sq.Area() sh.Area() } Area of the square is 100 Area of the square is 100 Run this code in Go Playground\nIn the above program, type Square is implementing the Shape interface. In the main function, we call the implemented method Area on variable sq of type Square and on variable sh of type Shape interface and the program still works fine.\nInterface\u0026rsquo;s types and values The variable of an interface stores, a concrete value and the type of that concrete value called concrete type. This representation can be envisaged as a tuple (type, value). An interface variable can store any concrete type and value as long as that type and value implement the interface\u0026rsquo;s method. The below program illustrate the type and value of the interface.\npackage main import \u0026quot;fmt\u0026quot; type Int int func (i Int) String() string { return fmt.Sprintf(\u0026quot;Value of Int is %d\u0026quot;, i) } type Float float32 func (f Float) String() string { return fmt.Sprintf(\u0026quot;Value of Float is %f\u0026quot;, f) } func describe(s fmt.Stringer) { fmt.Printf(\u0026quot;Concrete type of an interface is %T\\n\u0026quot;, s) fmt.Printf(\u0026quot;%v\\n\u0026quot;, s) fmt.Println() } func main() { var s fmt.Stringer describe(s) var i Int = 10 s = i describe(s) var f Float = 15.0005 s = f describe(f) } Concrete type of an interface is \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; Concrete type of an interface is main.Int Value of Int is 10 Concrete type of an interface is main.Float Value of Float is 15.000500 Run this code in Go Playground\nIn the above program:\nWe create two customs types Int and Float whose underlying types are int and float32 respectively. Both types implement fmt.Stringer interface by implementing String() string function.\nThe statement var s fmt.Stringer creates variable of an interface fmt.Stringer with zero value \u0026lt;nil\u0026gt;.\nIn the main function, we assign variable of type Int and Float to the interface variable s. This means when a particular type implements an interface then the variable of that type can also be represented as the type of an interface.\nThe type and value of the interface depend on the type and which implements that interface. Sometimes the concrete type and value of an interface are also called dynamic type and value. We call it dynamic because we can assign any type to the interface as long as that type implements the interface.\nZero Value of an interface The zero value of an interface is \u0026lt;nil\u0026gt;. A nil interface has its concrete value and concrete type nil.\npackage main import \u0026quot;fmt\u0026quot; func main() { var s fmt.Stringer fmt.Printf(\u0026quot;The concrete type of a nil interface is %T\\n\u0026quot;, s) fmt.Printf(\u0026quot;The concrete value of a nil interface is %v\u0026quot;, s) } The concrete type of a nil interface is \u0026lt;nil\u0026gt; The concrete value of a nil interface is \u0026lt;nil\u0026gt; Run this code in Go Playground\nIf we try to call a method on a nil interface, the program will panic.\npackage main import \u0026quot;fmt\u0026quot; type Day string func (day Day) String() string { return string(day) } func main() { var s fmt.Stringer fmt.Println(\u0026quot;The day is \u0026quot;, s.String()) } panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x497683] goroutine 1 [running]: main.main() /tmp/sandbox117008893/prog.go:13 +0x23 Run this code in Go Playground\nThe error pretty much is self-explanatory. The underlying concrete value and type are nil so the method can not be called on that object.\nEmpty Interface An interface with zero methods is called an empty interface. The empty interface is represented by interface{}.\nSince an empty interface has no methods it is implemented by all the types. Let\u0026rsquo;s dive into an example:\npackage main import \u0026quot;fmt\u0026quot; func getType(s interface{}) { fmt.Printf(\u0026quot;%T\\n\u0026quot;, s) } func main() { i := 10 getType(i) s := \u0026quot;Hola\u0026quot; getType(s) f := 12.24 getType(f) b := true getType(b) } int string float64 bool Run this code in Go Playground\nThe function getType(s interface{}) accepts an empty interface as an argument hence we were able to pass any type of variable to the function.\nHave you ever wondered how the Println function can accept any number of values of different different types and print it? The answer is interface{}.\nThis is the signature of Println function func Println(a ...interface{}) (n int, err error). The Println function is a variadic function which can take arguments of type interface{}.\nImplementing multiple interfaces A type can implement more than one interface. Let\u0026rsquo;s see how it is done.\npackage main import ( \u0026quot;fmt\u0026quot; ) type Shape interface { Area() } type Quadrilateral interface { isQuadrilateral() bool } type square struct { noOfSides int side int } func (s square) Area() { fmt.Printf(\u0026quot;Area of the square is %d\\n\u0026quot;, s.side*s.side) } func (s square) isQuadrilateral() bool { if s.noOfSides == 4 { return true } return false } func main() { s := square{ noOfSides: 4, side: 10, } var sh Shape = s sh.Area() var q Quadrilateral = s fmt.Println(q.isQuadrilateral()) } Area of the square is 100 true Run this code in Go Playground\nIn the above example, we\u0026rsquo;ve two interfaces Shape and Quadrilateral. Type square implements both interfaces. The program is easy and self-explanatory.\nEmbedding interfaces In Golang, one interface can embed any other interface. Golang does not support inheritance but this embedding of interfaces can give a sense of inheritance. Below is an illustrative example:\npackage main import ( \u0026quot;fmt\u0026quot; ) type Shape interface { Area() } type Quadrilateral interface { Shape fmt.Stringer isQuadrilateral() bool } type square struct { noOfSides int side int } func (s square) Area() { fmt.Printf(\u0026quot;Area of the square is %d\\n\u0026quot;, s.side*s.side) } func (s square) isQuadrilateral() bool { if s.noOfSides == 4 { return true } return false } func (s square) String() string { return fmt.Sprintf(\u0026quot;Number of sides are %d and dimension of side is %d\u0026quot;, s.noOfSides, s.side) } func main() { s := square{ noOfSides: 4, side: 10, } var q Quadrilateral = s fmt.Println(s.String()) s.Area() fmt.Println(q.isQuadrilateral()) } Number of sides are 4 and dimension of side is 10 Area of the square is 100 true Run this code in Go Playground\nIn the above example, we have Shape and fmt.Stringer interfaces which are embedded in the Quadrilateral interface. The type square implements method from Shape, fmt.Stringer and Quadrilateral interfaces. In the main function, we\u0026rsquo;re creating a variable of type square and assigning it to the variable of the Quadrilateral interface. After that, we\u0026rsquo;re calling all the method implemented by type square using only the variable of the Quadrilateral interface.\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Structs Part-2   \u0026emsp; • Contents   \u0026emsp; Interface Part-2 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/interface_part_1/"
  },{
    "title": "Structs part-2",
    "date": "",
    "description": "",
    "body": "Nested Structs Golang allows us to use struct as a field of another struct, this pattern is called nesting. A nested struct can be defined using the following syntax.\ntype struct1 struct{ // fields } type struct2 struct{ // fields s struct1 } Suppose we need to collect the data of a person, person\u0026rsquo;s name, age and address. In address, we need to collect the city and country of that person. So we can do this using nested structs as shown below:\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int address Address } type Address struct { city, country string } func main() { person := \u0026amp;Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, address: Address{ city: \u0026quot;London\u0026quot;, country: \u0026quot;UK\u0026quot;, }, } fmt.Printf(\u0026quot;%#v\u0026quot;, person) } \u0026amp;main.Person{name:\u0026quot;James Bond\u0026quot;, age:34, address:main.Address{city:\u0026quot;London\u0026quot;, country:\u0026quot;UK\u0026quot;}} Run this code in Go Playground\nAccessing fields of nested struct To access the fields of nested struct we can do structObj1.structObj2.structObj3........fieldName.\nBelow is an example:\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int address Address } type Address struct { city, country string } func main() { person := \u0026amp;Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, address: Address{ city: \u0026quot;London\u0026quot;, country: \u0026quot;UK\u0026quot;, }, } fmt.Printf(\u0026quot;Name: %v\\n\u0026quot;, person.name) fmt.Printf(\u0026quot;Age: %v\\n\u0026quot;, person.age) fmt.Printf(\u0026quot;City: %v\\n\u0026quot;, person.address.city) fmt.Printf(\u0026quot;Country: %v\\n\u0026quot;, person.address.country) } Name: James Bond Age: 34 City: London Country: UK Run this code in Go Playground\nPromoted fields When the struct has another struct as an anonymous field then fields of anonymous structs are called promoted fields. This means we can access the fields of the nested struct without using the object of the nested struct, we can access them just by using the parent struct.\nFor example:\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int Address } type Address struct { city, country string } func main() { person := \u0026amp;Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, Address: Address{ city: \u0026quot;London\u0026quot;, country: \u0026quot;UK\u0026quot;, }, } fmt.Printf(\u0026quot;Name: %v\\n\u0026quot;, person.name) fmt.Printf(\u0026quot;Age: %v\\n\u0026quot;, person.age) fmt.Printf(\u0026quot;City: %v\\n\u0026quot;, person.city) // Instead of person.address.city we used person.city fmt.Printf(\u0026quot;Country: %v\\n\u0026quot;, person.country) // Instead of person.address.country we used person.country } Name: James Bond Age: 34 City: London Country: UK Run this code in Go Playground\nOnly unique fields of nested anonymous struct gets promoted.\nIf the parent struct and nested anonymous struct has the same name field then that field will not be promoted.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int City } type City struct { name, country string } func main() { person := \u0026amp;Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, City: City{ name: \u0026quot;London\u0026quot;, country: \u0026quot;UK\u0026quot;, }, } fmt.Printf(\u0026quot;Name: %v\\n\u0026quot;, person.name) fmt.Printf(\u0026quot;Age: %v\\n\u0026quot;, person.age) fmt.Printf(\u0026quot;City: %v\\n\u0026quot;, person.City.name) fmt.Printf(\u0026quot;Country: %v\\n\u0026quot;, person.country) } Run this code in Go Playground\nIn this example, we have City a nested anonymous struct, whose fields are name and country. The name field is also available in Person struct. So when we try person.name then the compiler will give us access to Person\u0026rsquo;s name field by default hence to access the name field from City struct we\u0026rsquo;ve to do person.City.name. The country field from City struct is unique here so we can just access it by using person.country.\nComparing struct Structs in golang are value type and so they can be compared.\nTwo struct values may be equal if:\n They\u0026rsquo;re of the same type. Their corresponding fields are equal. Their corresponding fields should be comparable.  For example:\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func main() { p1 := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, } p2 := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, } fmt.Println(p1 == p2) // true } Run this code in Go Playground\nComparing pointers to the struct will always be false, we need to compare dereferenced pointer values.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func main() { p1 := \u0026amp;Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, } p2 := \u0026amp;Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, } fmt.Println(p1 == p2) // false fmt.Println(*p1 == *p2) // true } Run this code in Go Playground\nIf structs contain incomparable values then struct values can not be compared using == operator, it will throw an error.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int measures map[string]float32 } func main() { p1 := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, measures: map[string]float32{ \u0026quot;Height\u0026quot;: 183, \u0026quot;Weight\u0026quot;: 76, }, } p2 := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, measures: map[string]float32{ \u0026quot;Height\u0026quot;: 183, \u0026quot;Weight\u0026quot;: 76, }, } fmt.Println(p1 == p2) } ./prog.go:30:18: invalid operation: p1 == p2 (struct containing map[string]float32 cannot be compared) In the above code, a map is used as a field in a struct and a map is an incomparable type. To compare such structs we can use reflect.DeepEqual() function.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;reflect\u0026quot; ) type Person struct { name string age int measures map[string]float32 } func main() { p1 := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, measures: map[string]float32{ \u0026quot;Height\u0026quot;: 183, \u0026quot;Weight\u0026quot;: 76, }, } p2 := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, measures: map[string]float32{ \u0026quot;Height\u0026quot;: 183, \u0026quot;Weight\u0026quot;: 76, }, } fmt.Println(reflect.DeepEqual(p1, p2)) // true } Run this code in Go Playground\nStructs and methods/receiver function Golang supports both function and method. A method is a function that is defined for a particular type or with a receiver. A method in Golang also called a receiver function. Following is the example.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func (p Person) GetInfo() string { return fmt.Sprintf(\u0026quot;\\\u0026quot;%v\\\u0026quot; is \\\u0026quot;%v\\\u0026quot; years old.\u0026quot;, p.name, p.age) } func main() { p := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, } fmt.Println(p.GetInfo()) } \u0026quot;James Bond\u0026quot; is \u0026quot;34\u0026quot; years old. Run this code in Go Playground\nWe can also use a pointer as the receiver of the method. The difference between value as receiver and pointer as a receiver is, golang passes everything as value and hence in value receiver the function will get a copy of struct and function will not touch original struct whereas in pointer as a receiver function will get a copy of a pointer which will be pointing to an original struct.\nThe below examples illustrates the difference between pointer and value as a receiver.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } // Value as receiver func (p Person) UpdateAge(age int) { p.age = age } // Pointer as receiver func (p *Person) UpdateName(name string) { p.name = name } func main() { p := Person{ name: \u0026quot;James Bond\u0026quot;, age: 34, } // Value as receiver example fmt.Println(\u0026quot;Age before update: \u0026quot;, p.age) p.UpdateAge(24) fmt.Println(\u0026quot;Age after update: \u0026quot;, p.age) fmt.Println() // Pointer as receiver fmt.Println(\u0026quot;Name before update: \u0026quot;, p.name) p.UpdateName(\u0026quot;Jon Snow\u0026quot;) fmt.Println(\u0026quot;Name after update: \u0026quot;, p.name) } In above example UpdateAge() is using value as receiver and UpdateName() is using pointer as a receiver.\nAge before update: 34 Age after update: 34 Name before update: James Bond Name after update: Jon Snow Run this code in Go Playground\nEmpty Struct In GOlang, we can have an empty struct. A struct without any field is called an empty struct. Below is the signature of an empty struct.\ntype T struct{} var s struct{} Empty struct does not have any field so it does not occupy any memory i.e it occupies zero bytes of storage.\nvar s struct{} fmt.Println(unsafe.Sizeof(s)) // prints 0 We can create an array of the empty struct and still it occupies zero bytes.\nvar arr [100000]struct{} fmt.Println(unsafe.Sizeof(arr)) // prints 0 The slice of structs will consume some byte just to store pointer, length and capacity of an underlying array but structs still will be of zero bytes.\nsls := make([]struct{}, 100000) fmt.Println(unsafe.Sizeof(sls)) // prints 24 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;unsafe\u0026quot; ) func main() { var s struct{} fmt.Println(\u0026quot;Size of an empty struct: \u0026quot;, unsafe.Sizeof(s)) // prints 0 var arr [100000]struct{} fmt.Println(\u0026quot;Size of an array of an empty struct: \u0026quot;, unsafe.Sizeof(arr)) // prints 0 sls := make([]struct{}, 100000) fmt.Println(\u0026quot;Size of a slice of an empty struct: \u0026quot;, unsafe.Sizeof(sls)) // prints 24 } Size of an empty struct: 0 Size of an array of an empty struct: 0 Size of a slice of an empty struct: 24 Run this code in Go Playground\nRead more about the empty struct and its use cases at Dave Cheney\u0026rsquo;s blog.\nArray/Slice of structs The Array/Slice is a collection of the same type of element in a contiguous memory location. We can create an array/slice of structs.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func newPerson(name string, age int) *Person { return \u0026amp;Person{ name: name, age: age, } } func main() { people := make([]*Person, 0) // slice of a struct Person with initial length 0 people = append(people, newPerson(\u0026quot;James Bond\u0026quot;, 34)) people = append(people, newPerson(\u0026quot;Jon Snow\u0026quot;, 24)) people = append(people, newPerson(\u0026quot;Joey Tribbiani\u0026quot;, 32)) for _, person := range people { fmt.Println(person) } fmt.Println(\u0026quot;Name of friends character: \u0026quot;, people[2].name) } \u0026amp;{James Bond 34} \u0026amp;{Jon Snow 24} \u0026amp;{Joey Tribbiani 32} Name of friends character: Joey Tribbiani Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Structs part-1   \u0026emsp; • Contents   \u0026emsp; Interface Part-1 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/structs_part_2/"
  },{
    "title": "Structs part-1",
    "date": "",
    "description": "",
    "body": "What is Struct? A struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique. From golang docs.\nIn simple words, a struct is a user-defined type that allows the collection of different types of elements. These elements are called fields. Structs can be used to keep certain data together. A struct is a very popular and widely used user-defined type in golang.\nStruct Declaration and Initialization A struct is defined using keyword type and struct. Type keyword is used to define user-defined data types and the struct keyword specifies that it\u0026rsquo;s a struct.\ntype Person struct { name string age int } To use the struct we create a struct object.\nvar p Person or shorthand p := Person{} will create an object of struct Person and will initialize its field with zero-value of their type.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func main() { var p Person fmt.Printf(\u0026quot;%#v\u0026quot;, p) p1 := Person{} fmt.Printf(\u0026quot;%#v\\n\u0026quot;, p1) } main.Person{name:\u0026quot;\u0026quot;, age:0} main.Person{name:\u0026quot;\u0026quot;, age:0} %#v a Go-syntax representation of the value.\nRun this code in Go Playground\nStruct literals\nCreating a struct object with specifying field names\np := Person{name: \u0026quot;Jon Snow\u0026quot;, age: 24} p1 := Person{ name: \u0026quot;Jon Snow\u0026quot;, age: 24, } Order of the field does not matter when specifying field names\np := Person{age: 24, name: \u0026quot;Jon Snow\u0026quot;} Creating a struct object without specifying field names\np := Person{\u0026quot;Jon Snow\u0026quot;, 24} p1 := Person{ \u0026quot;Jon Snow\u0026quot;, 24, } package main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func main() { p := Person{name: \u0026quot;Jon Snow\u0026quot;, age: 24} fmt.Printf(\u0026quot;%#v\\n\u0026quot;, p) p1 := Person{\u0026quot;Jon Snow\u0026quot;, 24} fmt.Printf(\u0026quot;%#v\\n\u0026quot;, p1) p2 := Person{ name: \u0026quot;Jon Snow\u0026quot;, age: 24, } fmt.Printf(\u0026quot;%#v\\n\u0026quot;, p2) p3 := Person{ \u0026quot;Jon Snow\u0026quot;, 24, } fmt.Printf(\u0026quot;%#v\\n\u0026quot;, p3) } Run this code in Go Playground\nAccessing struct fields To access individual fields of the struct . operator is used. e.g.struct.fieldname.\nTo use the value present in a struct field.\nvalue := struct.fieldname To assign a new value to the struct field\nstruct.fieldname = value The below example demonstrates how to access the struct fields.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func main() { p := Person{name: \u0026quot;Jon Snow\u0026quot;, age: 24} fmt.Printf(\u0026quot;Name of the person: %v\\n\u0026quot;, p.name) fmt.Printf(\u0026quot;Age of the person: %v\\n\u0026quot;, p.age) p.age = 30 fmt.Printf(\u0026quot;Updated age of the person: %v\\n\u0026quot;, p.age) } Name of the person: Jon Snow Age of the person: 24 Age of the person: 30 Run this code in Go Playground\nPointer to the struct Pointers are special variable that stores address of another variable. We can store address of an struct object in pointer by passing the memory address using \u0026amp; operator.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func main() { // First way of creating pointer to struct personPtr := \u0026amp;Person{name: \u0026quot;James Bond\u0026quot;, age: 32} fmt.Println(personPtr) fmt.Println(*personPtr) // Dereferencing the struct pointer fmt.Printf(\u0026quot;Age of \\\u0026quot;%v\\\u0026quot; is \\\u0026quot;%v\\\u0026quot; \\n\u0026quot;, (*personPtr).name, (*personPtr).age) fmt.Println() // Second way of creating pointer to struct person := Person{name: \u0026quot;Jon Snow\u0026quot;, age: 24} ptr := \u0026amp;person fmt.Println(ptr) fmt.Println(*ptr) // Dereferencing the struct pointer fmt.Printf(\u0026quot;Age of \\\u0026quot;%v\\\u0026quot; is \\\u0026quot;%v\\\u0026quot; \\n\u0026quot;, (*ptr).name, (*ptr).age) } \u0026amp;{James Bond 32} {James Bond 32} Age of \u0026quot;James Bond\u0026quot; is \u0026quot;32\u0026quot; \u0026amp;{Jon Snow 24} {Jon Snow 24} Age of \u0026quot;Jon Snow\u0026quot; is \u0026quot;24\u0026quot; Run this code in Go Playground\nIn the above program, we\u0026rsquo;re accessing the struct field by dereferencing the pointer (*ptr).name, (*ptr).age which reduces the readability and makes a program a little unkempt. The Golang also allow us to access fields of the struct without dereferencing the pointer as shown in the below example.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string age int } func main() { // First way of creating pointer to struct person := \u0026amp;Person{name: \u0026quot;James Bond\u0026quot;, age: 32} fmt.Println(person) fmt.Printf(\u0026quot;Age of \\\u0026quot;%v\\\u0026quot; is \\\u0026quot;%v\\\u0026quot; \\n\u0026quot;, person.name, person.age) } \u0026amp;{James Bond 32} Age of \u0026quot;James Bond\u0026quot; is \u0026quot;32\u0026quot; Run this code in Go Playground\nIn the above program, we\u0026rsquo;re accessing the field using person.name, person.age.\nAnonymous Struct and anonymous fields Anonymous Struct In Golang we\u0026rsquo;re allowed to create a struct without a name such a struct is called an anonymous struct. This kind of struct is useful if we want to use the struct only once in the program. We can create a struct using the following syntax:\nvariable := struct{ // field }{ // field value } // OR PtrVariable := \u0026amp;struct{ // field }{ // field value } Below is an example of an anonymous struct.\npackage main import \u0026quot;fmt\u0026quot; func main() { person := struct { name string age int }{ name: \u0026quot;James Bond\u0026quot;, age: 32, } fmt.Println(person) ptrPerson := \u0026amp;struct { name string age int }{ name: \u0026quot;Jon Snow\u0026quot;, age: 24, } fmt.Println(ptrPerson) } {James Bond 32} \u0026amp;{Jon Snow 24} Run this code in Go Playground\nAnonymous fields In Golang we\u0026rsquo;re allowed to define anonymous fields in a struct. Anonymous fields are fields without a name. We just need to define the type of the field and GO will use that type as the name of that field. Below is the syntax of anonymous fields\ntype structName struct{ // value type string int bool } package main import \u0026quot;fmt\u0026quot; type Person struct { string int } func main() { person := \u0026amp;Person{ \u0026quot;James Bond\u0026quot;, 32, } fmt.Println(person) fmt.Printf(\u0026quot;Age of \\\u0026quot;%v\\\u0026quot; is \\\u0026quot;%v\\\u0026quot; \\n\u0026quot;, person.string, person.int) } \u0026amp;{James Bond 32} Age of \u0026quot;James Bond\u0026quot; is \u0026quot;32\u0026quot; Run this code in Go Playground\nIn above example we access the anonymous fields by using value type as name of the field person.string, person.int.\nIt is not allowed to define anonymous fields of the same type more than once.\nIf we try to define struct as following golang will throw an error.\ntype Person struct { string int string } ./prog.go:8:2: duplicate field string If we name one of the string fields then this error will not occur.\npackage main import \u0026quot;fmt\u0026quot; type Person struct { name string int string } func main() { person := \u0026amp;Person{ \u0026quot;James Bond\u0026quot;, 32, \u0026quot;Say Hello\u0026quot;, } fmt.Println(person) } \u0026amp;{James Bond 32 Say Hello} Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Pointers   \u0026emsp; • Contents   \u0026emsp; Structs part-2 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/structs_part_1/"
  },{
    "title": "Pointers",
    "date": "",
    "description": "",
    "body": "The pointer is a special variable in Golang that stores the memory address of other variables.\nVariables are used to store some type of data. All variables are assigned a particular memory where they store data and this memory has a memory address that is in hexadecimal format. The number that starts with 0x is hexadecimal like (0x14 which is equivalent to 20 in decimal). Golang allows us to store this memory address in variables but only pointers will understand that the stored value is pointing to some memory whereas other variables will treat it just as a value.\nDeclaring Pointer The type *T is a pointer to a T value. It\u0026rsquo;s zero value is \u0026lt;nil\u0026gt;.\nvar pointer_name *Data_Type var p *int = \u0026amp;variable In the above snippet, you can see two symbols * and \u0026amp;, which are two operators.\n* Operator is also called dereferencing operator which is used to declare an operator and also to access the value stored at the memory address pointer pointing to.\n\u0026amp; Operator this operator is used to access the memory address of a variable.\nBelow is an example demoing the use of * and \u0026amp;.\npackage main import \u0026quot;fmt\u0026quot; func main() { i := 42 var p *int = \u0026amp;i fmt.Println(\u0026quot;The value of i is: \u0026quot;, *p) fmt.Println(\u0026quot;The memory address of i is\u0026quot;, p) } The value of i is: 42 The memory address of i is 0xc00002c008 Run this code in Go Playground\nShorthand declaration In Golang shorthand declaration(:=) is used to narrow down the variable declaration. The Golang compiler will decide if the RHS variable is a pointer variable if we\u0026rsquo;re assigning the memory address of the LHS variable using \u0026amp;.\ni := 42 p := \u0026amp;i Declaring pointer with the new function Golang has a built-in allocating primitive function called new. The new(T) allocates memory, initializes it with zero-value of type T and returns the pointer to that memory. In Go terminology, it returns a pointer to a newly allocated zero value of type T.\nWhat is the difference between var p *int and p := new(int)?\nThe expression var p *int only declares the pointer and does not initialize it with any memory address, i.e pointer does not point to any memory location. Whereas in new(T) function returns the pointer pointing to the memory location in the system.\npackage main import \u0026quot;fmt\u0026quot; func main() { var p *int fmt.Println(\u0026quot;The value of p\u0026quot;, p) p1 := new(int) fmt.Println(\u0026quot;The value of *p1 is: \u0026quot;, *p1) fmt.Println(\u0026quot;The value of p1\u0026quot;, p1) } The value of p \u0026lt;nil\u0026gt; The value of *p1 is: 0 The value of p1 0xc00002c008 In the above example, we can not dereference pointer p because it has \u0026lt;nil\u0026gt; value. Trying to dereference it will throw an error.\npanic: runtime error: invalid memory address or nil pointer dereference Run this code in Go Playground\nPassing pointer to the function We can pass a pointer to the function as we pass other variables. We can create a pointer to the variable and then pass it to the function or we can just pass an address of that variable using \u0026amp;.\nIn the below example we initialize a variable i with the value 10. We\u0026rsquo;ve function addTen(i *int) which takes a pointer as an argument and then it adds 10 by dereferencing the pointer hence mutating the original value.\npackage main import \u0026quot;fmt\u0026quot; func addTen(i *int) { *i = *i + 10 } func main() { i := 10 p := \u0026amp;i fmt.Println(i) addTen(p) // Pass a pointer fmt.Println(i) addTen(\u0026amp;i) // Pass address using \u0026amp; operator fmt.Println(i) } 10 20 30 Run this code in Go Playground\nPass-by-value vs Pass-by-pointer When we write a function we decide parameters to be passed by-value or by-pointer.\nPass by value\nEvery time variable is passed as a parameter the new copy of that variable is created and passed to the function. This copy has a different memory location hence any changed to this copy will not affect the original variable.\nIn the below example we pass the parameter by value.\npackage main import \u0026quot;fmt\u0026quot; func add(i int) { i = i + 10 fmt.Println(\u0026quot;Variable copy from add function:\u0026quot;, i) } func main() { i := 10 fmt.Println(\u0026quot;Original variable:\u0026quot;, i) add(i) fmt.Println(\u0026quot;Original variable:\u0026quot;, i) } Original variable: 10 Variable copy from add function: 20 Original variable: 10 Run this code in Go Playground\nPass by Pointer\nWhen we pass parameter by-pointer Go makes the copy of that pointer to the new location. This pointer copy has the same memory address stored in it hence it is pointing to the original variable and any changes done using this pointer will change the value of the original variable.\npackage main import \u0026quot;fmt\u0026quot; func add(i *int) { *i = *i + 10 fmt.Println(\u0026quot;Variable copy from add function:\u0026quot;, *i) } func main() { i := 10 fmt.Println(\u0026quot;Original variable:\u0026quot;, i) add(\u0026amp;i) fmt.Println(\u0026quot;Original variable:\u0026quot;, i) } Original variable: 10 Variable copy from add function: 20 Original variable: 20 Run this code in Go Playground\nIn some way we can say pass-by-pointer is an implementation of pass-by-value.\nContainer types(slices, maps etc) and pointers package main import ( \u0026quot;fmt\u0026quot; ) func modify(h map[int]int) { h[1] = 5 fmt.Println(\u0026quot;Modified map: \u0026quot;, h) } func main() { m := make(map[int]int) m[1] = 1 m[2] = 2 m[3] = 3 fmt.Println(\u0026quot;Original map: \u0026quot;, m) modify(m) fmt.Println(\u0026quot;Original map: \u0026quot;, m) } In the above example, we\u0026rsquo;re creating a map and passing it to the modify function. With the cursory look, it seems like we\u0026rsquo;re passing an argument by-value because we\u0026rsquo;re not passing the address of map m using \u0026amp; or by creating a pointer to map m. So this means the copy of map m should be created and the original map is untouched. But if we run this we get an output as follows.\nOriginal map: map[1:1 2:2 3:3] Modified map: map[1:5 2:2 3:3] Original map: map[1:5 2:2 3:3] Run this code in Go Playground\nWe passed an argument by-value then why did the original map was updated?\nWhen we create a map using m := make(map[int]int) the compiler makes call to the runtime.makemap function whose signature is as func makemap(t *maptype, hint int, h *hmap) *hmap.\nSo as we see, the return type of runtime.makemap is a pointer to the runtime.hmap structure. So when we passed a map to the function we actually passed a pointer to the runtime.hmap structure of map m and hence the original map was modified.\nInstead of map if we try above program using slice we will get the similar output because slice variable stores the pointer to underlying array read more about Arrays and Slices here.\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Closures   \u0026emsp; • Contents   \u0026emsp; Structs part-1 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/pointers/"
  },{
    "title": "Closures",
    "date": "",
    "description": "",
    "body": "Golang supports anonymous functions which are then used to form closure functions. Anonymous functions are function without any name. Before going any further read about anonymous function .\nThe closure is a special type of function value which references variable declared outside its body. The purpose of this function is to close over a variable of upper function to form a closure. The function may access and assign to the referenced variables; in this sense, the function is \u0026ldquo;bound\u0026rdquo; to the variables.\nLet\u0026rsquo;s see an example. In this example, we create a closure which keeps track of page hit or as a counter.\npackage main import \u0026quot;fmt\u0026quot; func main() { hit := 0 counter := func() int { hit += 1 return hit } fmt.Println(counter()) fmt.Println(counter()) fmt.Println(counter()) } Run this code in Go Playground\nIn the above example, we bound the closure to hit variable which is not passed to it but accessed as a global variable.\nThe problem with the above code is, hit is a global variable. Hence another function has access to it. So any other operation can change the value of hit. To avoid this closure can isolate the data.\npackage main import \u0026quot;fmt\u0026quot; func main() { counter := Counter() fmt.Println(counter()) fmt.Println(counter()) fmt.Println(counter()) } func Counter() func() int { hit := 0 return func() int { hit++ return hit } } Run this code in Go Playground\nIn the above example closure is bound to or references to the hit variable which is still can be accessed after the function call. This means closure has access to the data and no other function has access to it and hence this data can be tracked and isolated. This is one of the benefits of closure.\nSome closure use cases Isolating the data Suppose we want to create a function that persists data after the functional call exists. For example, we create a Fibonacci series generator where we want to keep all variables away from the user\u0026rsquo;s eye, so no one can manipulate it.\npackage main import \u0026quot;fmt\u0026quot; func fibonacci() func() int { n1 := 0 n2 := 1 return func() int { n1, n2 = n2, (n1 + n2) return n1 } } func main() { f := fibonacci() fmt.Println(0) for i := 0; i \u0026lt; 10; i++ { fmt.Println(f()) } } Run this code in Go Playground\nSearch in sorting package A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered.\nfunc Search(n int, f func(int) bool) int package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sort\u0026quot; ) func main() { nums := []int{1, 3, 6, 8, 10, 15, 21, 28, 36, 45, 55} x := 8 i := sort.Search(len(nums), func(i int) bool { return nums[i] \u0026gt;= x }) fmt.Printf(\u0026quot;Index of %d is %d\u0026quot;, x, i) } Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Anonymous Function   \u0026emsp; • Contents   \u0026emsp; Pointers 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/closures/"
  },{
    "title": "Anonymous Function",
    "date": "",
    "description": "",
    "body": "The anonymous function is a feature in Golang which let us define a function without a name. This feature is also called a function literal. This is useful when you want an inline function or to form a closure.\nDeclaring the anonymous function The syntax is pretty straight forward and much similar to normal function.\nfunc(parameter_list)(return_type){ return }() Parameter list and return type are optional.\n() this will invoke the function as soon as it is defined.\npackage main import \u0026quot;fmt\u0026quot; func main() { func() { fmt.Println(\u0026quot;Golang Rocks!\u0026quot;) }() } Run this code in Go Playground\nAssigning anonymous function to a variable In golang, you can assign an anonymous function to a variable. The assigned variable will be the type of function type and it can be called like a regular function.\npackage main import \u0026quot;fmt\u0026quot; func main() { v := func() { fmt.Println(\u0026quot;Golang Rocks!\u0026quot;) } fmt.Printf(\u0026quot;Type of variable v: %T\\n\u0026quot;, v) v() } Type of variable v: func() Golang Rocks! Run this code in Go Playground\nPassing an argument to an anonymous function An anonymous function can take any number of arguments similar to normal function.\npackage main import \u0026quot;fmt\u0026quot; func main() { func(name string) { fmt.Println(\u0026quot;Hello, \u0026quot;, name) }(\u0026quot;Jack\u0026quot;) } Run this code in Go Playground\nWith any number of trailing arguments similar to Variadic functions\npackage main import \u0026quot;fmt\u0026quot; func main() { func(i ...int) { fmt.Println(i) }(1, 2, 3, 4) } Run this code in Go Playground\nPassing an anonymous function as an argument\nYou can pass an anonymous function as an argument to a regular function or an anonymous function.\n Anonymous function as an argument to regular function  package main import \u0026quot;fmt\u0026quot; func sayHello(af func(s string) string) { fmt.Println(af(\u0026quot;Jack\u0026quot;)) } func main() { sayHello(func(s string) string { return \u0026quot;Hello, \u0026quot; + s }) } Run this code in Go Playground\n Anonymous function as an argument to anonymous function  package main import \u0026quot;fmt\u0026quot; func main() { func(v string) { fmt.Println(v) }(func(s string) string { return \u0026quot;Hello, \u0026quot; + s }(\u0026quot;Jack\u0026quot;)) } Run this code in Go Playground\nThis above code looks a bit complicated and hard to fathom so another way we can achieve this is the following:\npackage main import \u0026quot;fmt\u0026quot; func main() { af := func(s string) string { return \u0026quot;Hello, \u0026quot; + s } func(af func(s string) string) { fmt.Println(af(\u0026quot;Jack\u0026quot;)) }(af) } Run this code in Go Playground\nReturn an anonymous function from another function We can return an anonymous function from another function\n Returning from regular function  package main import \u0026quot;fmt\u0026quot; func sayHello() func(s string) string { r := func(s string) string { return \u0026quot;Hello, \u0026quot; + s } return r } func main() { f := sayHello() fmt.Printf(\u0026quot;Type of variable f: %T\\n\u0026quot;, f) fmt.Println(f(\u0026quot;Jack\u0026quot;)) } Run this code in Go Playground\n Returning from anonymous function  package main import \u0026quot;fmt\u0026quot; func main() { f := func() func(s string) string { r := func(s string) string { return \u0026quot;Hello, \u0026quot; + s } return r } fmt.Printf(\u0026quot;Type of variable f: %T\\n\u0026quot;, f) c := f() fmt.Printf(\u0026quot;Type of variable c: %T\\n\u0026quot;, c) fmt.Println(c(\u0026quot;Jack\u0026quot;)) } Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Functions   \u0026emsp; • Contents   \u0026emsp; Closures 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/anonymous_func/"
  },{
    "title": "Functions",
    "date": "",
    "description": "",
    "body": "A function is a block of statements which performs a specific task. Functions is a well organized and reusable code. It improves the code readability, maintainability and testability. The general function is:\nfunc function_name( [parameter list] ) [return_types] { body of the function } Declaring and calling functions The function is declared using func keyword.\nfunc sayCheeze() { fmt.Println(\u0026quot;Cheeeeeeeeeeeeze\u0026quot;) } Calling the function is pretty easy.\nsayCheeze() package main import \u0026quot;fmt\u0026quot; func sayCheeze() { fmt.Println(\u0026quot;Cheeeeeeeeeeeeze\u0026quot;) } func main() { sayCheeze() } Run this code in Go Playground\nYou may pass input parameters func addition(i int, j int) { fmt.Println(i + j) } We need to pass the declared number of parameters while calling the function.\naddition(1, 2) When two or more consecutive parameters have the same type we can omit the type from all but last.\npackage main import \u0026quot;fmt\u0026quot; func addition(i, j, k int) { fmt.Println(i + j + k) } func main() { addition(10, 20, 30) } Run this code in Go Playground\nYou may define the return type of function func addition(i, j, k int) int { return i + j + k } sum := addition(1, 2, 3) A function can return any number of results.\npackage main import \u0026quot;fmt\u0026quot; func addition(i, j int) (int, int, int) { return i, j, i + j } func main() { a, b, sum := addition(1, 2) fmt.Println(a, b, sum) } Run this code in Go Playground\nNamed return values Go\u0026rsquo;s return values may be named. The named return values are treated as locally defined variables in the function.\npackage main import \u0026quot;fmt\u0026quot; func division(i int) (quotient, remainder int) { quotient = i / 10 remainder = i % 10 return } func main() { quotient, remainder := division(125) fmt.Printf(\u0026quot;Quotient: %d and Remainder: %d\u0026quot;, quotient, remainder) } Run this code in Go Playground\nVariadic functions Variadic functions can be called with any number of trailing arguments. For example, fmt.Println is a common variadic function.\npackage main import \u0026quot;fmt\u0026quot; func total(nums ...int) (total int) { for _, i := range nums { total += i } return total } func main() { fmt.Println(total(1, 2, 3, 4, 5)) fmt.Println(total(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) } Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Range   \u0026emsp; • Contents   \u0026emsp; Anonymous Function 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/functions/"
  },{
    "title": "Range",
    "date": "",
    "description": "",
    "body": "The range keyword is used to iterate over various data types. It is used in for loops and its return values are dependent on the data types over which we\u0026rsquo;re using range keyword.\nRange over slice/array Range on Array and Slice returns the first value as an index and second value as an element located at that index.\npackage main import \u0026quot;fmt\u0026quot; func main() { nums := []int{1, 2, 3, 4, 5} for i, v := range nums { fmt.Printf(\u0026quot;Index :%d, value: %d\\n\u0026quot;, i, v) } } Output:\nIndex :0, value: 1 Index :1, value: 2 Index :2, value: 3 Index :3, value: 4 Index :4, value: 5 Run this code in Go Playground\nRange over maps Range on Map returns the first value as a key and second value is a value associated with that key.\npackage main import \u0026quot;fmt\u0026quot; func main() { m := map[string]int{\u0026quot;foo\u0026quot;: 0, \u0026quot;bar\u0026quot;: 1} for k, v := range m { fmt.Printf(\u0026quot;Key :%s, value: %d\\n\u0026quot;, k, v) } } Output:\nKey :foo, value: 0 Key :bar, value: 1 Run this code in Go Playground\nRange over a string Range on String returns the first value as an index and second value is rune int.\npackage main import \u0026quot;fmt\u0026quot; func main() { str := \u0026quot;golang\u0026quot; for i, s := range str { fmt.Printf(\u0026quot;Index :%d, Rune value: %d\\n\u0026quot;, i, s) } } Output:\nIndex :0, Rune value: 103 Index :1, Rune value: 111 Index :2, Rune value: 108 Index :3, Rune value: 97 Index :4, Rune value: 110 Index :5, Rune value: 103 Run this code in Go Playground\nRune int value can be type cast string using string() method. e.g. string(103) == g\nRange over a channel Range on Channel returns only one value that is the value received from the channel.\npackage main import \u0026quot;fmt\u0026quot; func main() { channel := make(chan string, 2) channel \u0026lt;- \u0026quot;Hello\u0026quot; channel \u0026lt;- \u0026quot;World\u0026quot; close(channel) for v := range channel { fmt.Println(v) } } Run this code in Go Playground\n*KEEP IN MIND*\nYou can not update the value in the range loop.\npackage main import \u0026quot;fmt\u0026quot; func main() { nums := []int{1, 2, 3, 4, 5} fmt.Println(\u0026quot;Slice before range: \u0026quot;, nums) for _, v := range nums { v += 1 } fmt.Println(\u0026quot;Slice after range: \u0026quot;, nums) } Output:\nSlice before range: [1 2 3 4 5] Slice after range: [1 2 3 4 5] Run this code in Go Playground\nIn the above example, I try to increment all the values of the slice by 1 but the slice is unaffected. This is because the range loop copies the value from slice to local variable. So to update the slice we\u0026rsquo;ll need to use traditional way nums[i] += 1.\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Maps   \u0026emsp; • Contents   \u0026emsp; Functions 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/range/"
  },{
    "title": "Maps",
    "date": "",
    "description": "",
    "body": "The map is a collection of key-value pairs. It is an implementation of a Hash Table, which provides Create/Add, Read, Update and Delete operations over the data. Collection of key-value pairs is unordered and each key is unique.\nDeclaration and initialization In general GO map looks like\nmap[KeyType]ValueType The KeyType could be anything that is comparable such as string, int etc. and ValueType could be anything, even it can be another map.\nvar m map[int]string The above m is a map of int keys to string values.\nMaps are reference types such as slices. So uninitialized maps value is nil i.e the zero value of the map is nil. The nil map has no keys and we can not add any key to it because it does not point to any initialized map. Trying to add a key to nil map will throw panic: assignment to entry in nil map error.\npackage main import \u0026quot;fmt\u0026quot; func main() { var m map[int]string fmt.Printf(\u0026quot;%T\\n\u0026quot;, m) fmt.Println(m) m[1] = \u0026quot;one\u0026quot; } map[int]string map[] panic: assignment to entry in nil map goroutine 1 [running]: main.main() /tmp/sandbox272715404/prog.go:9 +0x107 Run this code in Go Playground\nSo to get an initialized and ready to use map use make function.\npackage main import \u0026quot;fmt\u0026quot; func main() { m := make(map[int]string) fmt.Printf(\u0026quot;%T\\n\u0026quot;, m) fmt.Println(m) m[1] = \u0026quot;one\u0026quot; fmt.Println(m) } map[int]string map[] map[1:one] Run this code in Go Playground\nIn the background make function assigns and initializes hash map data structure and returns map value which points to the hash map.\nMap literal\npackage main import \u0026quot;fmt\u0026quot; func main() { m := map[string]int{\u0026quot;foo\u0026quot;: 0, \u0026quot;bar\u0026quot;: 1} fmt.Printf(\u0026quot;%T\\n\u0026quot;, m) fmt.Println(m) } Run this code in Go Playground\nWorking with the maps Create a map using make function\nWe created a map m of string keys to int values.\nm := make(map[string]int) Add key-value pair\nThe syntax is fairly similar and easy to follow. Below key one is set to the value 1.\nm[\u0026quot;one\u0026quot;] = 1 Update operation has the same syntax\nm[\u0026quot;one\u0026quot;] = 2 Read a value\ni := m[\u0026quot;one\u0026quot;] If the key is not present then we get the value of type\u0026rsquo;s zero value.\nj := m[\u0026quot;two\u0026quot;] // Key not present // j == 0 We can check if the key is present in map with a two-value assignment statement.\nk, ok := m[\u0026quot;three\u0026quot;] _, ok := m[\u0026quot;three\u0026quot;] // Without retrieving the value. If the key is present ok == true if the key is not found ok == false.\nDelete value\nThe built-in delete function will delete the values from the map. It takes the map variable and key as an argument and it does not return anything. If the given key is not found it\u0026rsquo;ll not do anything.\ndelete(m, \u0026quot;one\u0026quot;) Iterating over the values in maps\nWe can use range to iterate.\nfor key, value := range m { fmt.Println(\u0026quot;Key:\u0026quot;, key, \u0026quot;Value:\u0026quot;, value) } While iterating over the map the iteration order is not specific, you may get different iteration order next time you iterate.\npackage main import \u0026quot;fmt\u0026quot; func main() { // **Create a map using make function** m := make(map[string]int) // **Add key-value pair** m[\u0026quot;one\u0026quot;] = 1 fmt.Println(\u0026quot;Value of m: \u0026quot;, m) // Update m[\u0026quot;one\u0026quot;] = 2 fmt.Println(\u0026quot;Updated value of m: \u0026quot;, m) fmt.Println() // **Read a value** i := m[\u0026quot;one\u0026quot;] fmt.Println(\u0026quot;Value of i\u0026quot;, i) // Key not present j := m[\u0026quot;two\u0026quot;] fmt.Println(\u0026quot;Value of j: \u0026quot;, j) fmt.Println() // check if the key is present key, ok := m[\u0026quot;three\u0026quot;] fmt.Println(key, ok) // Without retrieving the value. _, k := m[\u0026quot;three\u0026quot;] fmt.Println(k) fmt.Println() // **Delete value** delete(m, \u0026quot;one\u0026quot;) fmt.Println(\u0026quot;Value of m after deletion: \u0026quot;, m) fmt.Println() // **Iterating over the values in maps** m[\u0026quot;one\u0026quot;] = 1 m[\u0026quot;two\u0026quot;] = 2 m[\u0026quot;three\u0026quot;] = 3 fmt.Println(\u0026quot;Iterate over map\u0026quot;) for key, value := range m { fmt.Println(\u0026quot;Key:\u0026quot;, key, \u0026quot;Value:\u0026quot;, value) } } Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Arrays and Slices   \u0026emsp; • Contents   \u0026emsp; Range 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/maps/"
  },{
    "title": "Arrays and Slices",
    "date": "",
    "description": "",
    "body": "Array The array is a collection of the same type of element in a contiguous memory location. The array has fixed length i.e the number of elements to be stored is fixed before memory allocation.\nArray Declarations An array type definition specifies length and type of element. The array [n]T is of length n and type T.\n// This array can hold 3 integers. var i [3]int Arrays can be indexed in usual way, to access the nth element we can do a[n].\ni[0] = 1 i[1] = 10 i[2] = 100 Array literal\nj := [3]string{\u0026quot;Go\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;fun\u0026quot;} We can make compiler to compute the length of an array.\nj := [...]string{\u0026quot;Go\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;fun\u0026quot;} In both cases, the type of j is [3]string.\npackage main import \u0026quot;fmt\u0026quot; func main() { var i [3]int fmt.Println(\u0026quot;Values of array, i: \u0026quot;, i) fmt.Println(\u0026quot;Length of array, i: \u0026quot;, len(i)) i[0] = 1 i[1] = 10 i[2] = 100 fmt.Println(\u0026quot;Updated values of array, i: \u0026quot;, i) j := [3]string{\u0026quot;Go\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;fun\u0026quot;} fmt.Println(\u0026quot;Values of array, j: \u0026quot;, j) fmt.Println(\u0026quot;Length of array, j: \u0026quot;, len(j)) k := [...]string{\u0026quot;Go\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;fun\u0026quot;} fmt.Println(\u0026quot;Values of array, k: \u0026quot;, k) fmt.Println(\u0026quot;Length of array, k: \u0026quot;, len(k)) } Run this code in Go Playground\nSlices Arrays are a bit inflexible, so slices are widely used in GO. Slices are built on arrays giving it more flexibility, power and convenience.\nThe slice type is []T, specified without length and T is the element type.\nSlice formation A slice literal is like an array literal without the length.\npackage main import \u0026quot;fmt\u0026quot; func main() { i := []int{1, 2, 3, 4, 5} fmt.Println(i) fmt.Println(len(i)) } Run this code in Go Playground\nCreating a slice with make Slices can be created with the built-in make function; this is how you create dynamically-sized arrays.\nfunc make([]T, len, cap) []T Where,\n []T: Type of underlying array len: Length of the underlying array cap: Capacity of the underlying array, cap is optional  package main import \u0026quot;fmt\u0026quot; func main() { b := make([]int, 3, 5) fmt.Println(\u0026quot;Length: \u0026quot;, len(b)) fmt.Println(\u0026quot;Capacity: \u0026quot;, cap(b)) fmt.Println(\u0026quot;Values: \u0026quot;, b) } Run this code in Go Playground\nIf the capacity argument is omitted then capacity defaults to length.\npackage main import \u0026quot;fmt\u0026quot; func main() { b := make([]int, 3) fmt.Println(\u0026quot;Length: \u0026quot;, len(b)) fmt.Println(\u0026quot;Capacity: \u0026quot;, cap(b)) fmt.Println(\u0026quot;Values: \u0026quot;, b) } Run this code in Go Playground\nLength and capacity The length of a slice is the number of elements it contains.\nThe capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.\nLength: len(s)\nCapacity: cap(s)\nCreating a slice from an array Slice can be formed by specifying 2 indices, high bound and low bound separated by a colon, s[low : high]. This selects a half-open range which includes the first element but excludes the last one.\npackage main import \u0026quot;fmt\u0026quot; func main() { odds := [5]int{1, 3, 5, 7, 9} fmt.Println(\u0026quot;Length of odds array: \u0026quot;, len(odds)) fmt.Println(\u0026quot;Capacity of odds array: \u0026quot;, cap(odds)) fmt.Println(\u0026quot;Values of odds array: \u0026quot;, odds) fmt.Println() var o []int = odds[1:4] fmt.Println(\u0026quot;Length of o slice: \u0026quot;, len(o)) fmt.Println(\u0026quot;Capacity of o slice: \u0026quot;, cap(o)) fmt.Println(\u0026quot;Values of o slice: \u0026quot;, o) fmt.Println() m := odds[1:4] fmt.Println(\u0026quot;Length of m slice: \u0026quot;, len(m)) fmt.Println(\u0026quot;Capacity of m slice: \u0026quot;, cap(m)) fmt.Println(\u0026quot;Values of m slice: \u0026quot;, m) } Run this code in Go Playground\nWe can skip low or high bound to use their defaults. For low bound default is 0 and for high bound default is length of an array.\na[:high], a[low:]\nTo create a slice of an entire array we can omit both high bound and low bound.\nodds := [5]int{1, 3, 5, 7, 9} o := odds[:] Slice internals A slice does not store any data, it just describes a section of an underlying array.\nA slice consists of a pointer to the array segment, length of an array segment and its capacity (the maximum length of the segment).\n ptr (*Ele)   Length (int)   Capacity (int)   Relation of array and slice When we create a slice we create a slice variable which stores the pointer, length and capacity of the underlying array. Slicing does not copy the elements, it creates a new slice variable pointing to the original array. Hence changing element of the slice will make those changes to an underlying array and all other slices which share the same underlying array will be affected.\npackage main import \u0026quot;fmt\u0026quot; func main() { alphabet := [5]string{\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;D\u0026quot;} fmt.Println(\u0026quot;Initial values of alphabet: \u0026quot;, alphabet) i := alphabet[0:3] fmt.Println(\u0026quot;Initial values of i: \u0026quot;, i) j := alphabet[1:4] fmt.Println(\u0026quot;Initial values of j: \u0026quot;, j) i[2] = \u0026quot;P\u0026quot; // This changes will affect alphabet, i ,j slices fmt.Println() fmt.Println(\u0026quot;Updated values of alphabet: \u0026quot;, alphabet) fmt.Println(\u0026quot;Updated values of i: \u0026quot;, i) fmt.Println(\u0026quot;Updated values of j: \u0026quot;, j) } Initial values of alphabet: [A B C D ] Initial values of i: [A B C] Initial values of j: [B C D] Updated values of alphabet: [A B P D ] Updated values of i: [A B P] Updated values of j: [B P D] Run this code in Go Playground\nAppend and copy functions Append func append(s []T, x ...T) []T The append function appends the data at the end of the slice. If the destination slice has enough capacity then it is re-sliced to accommodate the new element but if capacity is not enough then new underlying array is created and allocated.\npackage main import \u0026quot;fmt\u0026quot; func main() { a := make([]int, 1) fmt.Println(\u0026quot;Length: \u0026quot;, len(a)) fmt.Println(\u0026quot;Capacity: \u0026quot;, cap(a)) fmt.Println(\u0026quot;Values: \u0026quot;, a) fmt.Println() a = append(a, 1, 2, 3) fmt.Println(\u0026quot;Length: \u0026quot;, len(a)) fmt.Println(\u0026quot;Capacity: \u0026quot;, cap(a)) fmt.Println(\u0026quot;Values: \u0026quot;, a) } Run this code in Go Playground\nAppending one slice to another\npackage main import \u0026quot;fmt\u0026quot; func main() { a := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;} b := []string{\u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;} a = append(a, b...) fmt.Println(\u0026quot;Length: \u0026quot;, len(a)) fmt.Println(\u0026quot;Capacity: \u0026quot;, cap(a)) fmt.Println(\u0026quot;Values: \u0026quot;, a) } Run this code in Go Playground\nCopy Slice can not grow beyond the capacity of the underlying array if it tries to grow will cause runtime panic error similar to index out of bounds error.\nnums := [3]int{1, 2, 3} // array n := nums[:] // slicing nums array n[3] = 4 // this will throw runtime error panic: runtime error: index out of range [3] with length 3 So one way to achieve the dynamic array is we can create a new bigger slice and copy the content from the old slice to a new slice.\npackage main import \u0026quot;fmt\u0026quot; func main() { nums := [3]int{1, 2, 3} // array n := nums[:] // slicing nums array fmt.Println(\u0026quot;Length: \u0026quot;, len(n)) fmt.Println(\u0026quot;Capacity: \u0026quot;, cap(n)) fmt.Println(\u0026quot;Values: \u0026quot;, n) fmt.Println() o := make([]int, len(n)+1) copy(o, n) o[3] = 4 fmt.Println(\u0026quot;Length: \u0026quot;, len(o)) fmt.Println(\u0026quot;Capacity: \u0026quot;, cap(o)) fmt.Println(\u0026quot;Values: \u0026quot;, o) } Run this code in Go Playground\nThe copy function takes destination slice and source slice as an argument and returns the number of elements copied.\nfunc copy(dst, src []T) int Examples Copy from one slice to another slice\nvar odds = make([]int, 3) n := copy(odds, []int{1, 3, 5}) // n == 3, odds == []int{1, 3, 5} Copy between same slice\nodds := []int{1, 3, 5} n := copy(odds, odds[1:]) // n == 2, s == []int{3, 5, 5} In this example, the values at index 0 and 1 are replaced by values at index 1 and 2.\nCopy from a string to a byte slice\nvar s = make([]byte, 5) copy(s, \u0026quot;Hello, world!\u0026quot;) // s == []byte(\u0026quot;Hello\u0026quot;) In this example, the slice s has a capacity of 5 elements so the only string Hello is copied to it.\npackage main import \u0026quot;fmt\u0026quot; func main() { // **Copy from one slice to another slice** var odds = make([]int, 3) copy(odds, []int{1, 3, 5}) fmt.Println(odds) // **Copy between same slice** nums := []int{1, 2, 3, 4} copy(nums, nums[1:]) fmt.Println(nums) // **Copy from a string to a byte slice** var s = make([]byte, 5) copy(s, \u0026quot;Hello, world!\u0026quot;) fmt.Println(s) fmt.Println(string(s)) } Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Switch Statement   \u0026emsp; • Contents   \u0026emsp; Maps 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/array_slice/"
  },{
    "title": "Switch",
    "date": "",
    "description": "",
    "body": "A switch statement is another way to write a sequence of if - else statements.\nGo\u0026rsquo;s switch is like the one in C and C++ except that it only runs the selected case, not all the cases that follows so we don\u0026rsquo;t need break statement here.\nswitch expression { case exp1: //Executes if expression matches exp1 case exp2: //Executes if expression matches exp2 default: //Executes if expression does not matches with any case } Switch evaluation order Switch cases evaluate cases from top to bottom and stops when a case succeeds.\nIn below example, it checks case \u0026quot;Linux\u0026quot;: if os matches with Linux then it stops at that case else go to the next case.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;runtime\u0026quot; ) func main() { //Prints which OS you're using switch os := runtime.GOOS; os { case \u0026quot;linux\u0026quot;: fmt.Println(\u0026quot;Linux.\u0026quot;) case \u0026quot;darwin\u0026quot;: fmt.Println(\u0026quot;OS X.\u0026quot;) default: fmt.Printf(\u0026quot;%s.\\n\u0026quot;, os) } } Run this code in Go Playground\nSwitch with NO condition Switch with no condition is like switch true. It is useful for writing long if-else-if ladder.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026quot;Good morning!\u0026quot;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026quot;Good afternoon.\u0026quot;) default: fmt.Println(\u0026quot;Good evening.\u0026quot;) } } Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Conditional Statements   \u0026emsp; • Contents   \u0026emsp; Arrays and Slices 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/switch/"
  },{
    "title": "Conditional Statements",
    "date": "",
    "description": "",
    "body": "Conditional Statements are part of every programming language. They help us to decide which instruction is suppose to run when certain condition is met. e.g. If I\u0026rsquo;m hungry then I\u0026rsquo;ll eat else I\u0026rsquo;ll wait. e.g. If score is greater than 35%, you passed, else you failed.\nIf statement in Go if condition/expression { //instruction to be performed } Condition needs to be true to perform the given set of instructions.\npackage main import \u0026quot;fmt\u0026quot; func main(){ i := 10 if i % 2 == 0 { fmt.Printf(\u0026quot;%d is a even number\u0026quot;, i) } } Run this code in Go Playground\nIf-Else statement in Go if condition/expression { //instruction to be performed } else { //instruction to be performed } If condition need to be false to perform instruction from else block.\npackage main import \u0026quot;fmt\u0026quot; func main(){ i := 11 if i % 2 == 0 { fmt.Printf(\u0026quot;%d is a even number\u0026quot;, i) } else { fmt.Printf(\u0026quot;%d is a odd number\u0026quot;, i) } } Run this code in Go Playground\nif-else-if ladder We can use multiple conditional statement at once which.\npackage main import \u0026quot;fmt\u0026quot; func main(){ i := -11 if i == 0 { fmt.Println(\u0026quot;It's zero\u0026quot;) } else if i \u0026lt; 0 { fmt.Println(\u0026quot;Negative number\u0026quot;) } else { fmt.Println(\u0026quot;Positive number\u0026quot;) } } Run this code in Go Playground\nIf with a short statement package main import \u0026quot;fmt\u0026quot; func main() { if j := 10; j%2 == 0 { fmt.Println(\u0026quot;Even number\u0026quot;) } } Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Looping Construct   \u0026emsp; • Contents   \u0026emsp; Switch Statement 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/if_else/"
  },{
    "title": "Looping Construct",
    "date": "",
    "description": "",
    "body": "Go has only one looping construct, the for loop.\nBasic for loop The basic for loop has three components separated by semicolons:\n init statement: i := 0 exec before 1st iteration condition expression: i \u0026lt; n eval on every interation post statement: i++ exec after each iteration  The expression is not surrounded by parentheses ( ) but the braces { } around set of instructions are required.\nfor i := 0; i \u0026lt; n; i++ { //business logic //set of instructions } Init and post statement are optional.\nfor ; i \u0026lt; n; { //business logic } For is also a while() loop for i \u0026lt; n { //business logic } Infinite loop for { //business logic } Example package main import \u0026quot;fmt\u0026quot; func main() { for i := 0; i \u0026lt; 5; i++ {fmt.Printf(\u0026quot;Iteration number: %d\\n\u0026quot;, i)} } Run this code in Go Playground\nIteration number: 0 Iteration number: 1 Iteration number: 2 Iteration number: 3 Iteration number: 4 Thank you for reading this blog please give your feedback in the comment section below.\n 🡄 Variables, data types and constants   \u0026emsp; • Contents   \u0026emsp; Conditional Statements 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/for_loop/"
  },{
    "title": "Variables, data types and constants",
    "date": "",
    "description": "",
    "body": "Variable Variable is a symbolic name given to the storage location which contains some value which can be changed at any time during the execution of the program. A variable must be defined with the type of data or value it is holding.\nData types There are several data types in Go.\nbool int uint float32 complex64 string int8 uint8 float64 complex128 byte int16 uint16 rune int32 uint32 error int64 uint64 Zero value In some programming languages variable holds a null or undefined value when not initialized, Go gives it a zero-value of its data type. A boolean variable if not initialized, gets the false value and an integer variable gets 0 value, string variable will get nil value.\nDeclaring a variable The var statement declares a list of variables. Type is at the last of the statement.\nvar varName dataType E.g.:\nvar i, j, k int var f float32 var u uint Variables with initializers\nWe can initialize variable while declaring.\nvar varName dataType = value var i int = 10 var s string = \u0026quot;hello\u0026quot; var ok bool = true We can omit the type of variable, it will take the type of initializers\nvar i = 42 // int var f = 3.142 // float64 var g = \u0026quot;hello\u0026quot; // string Short-hand declaration\nThis is the most commonly used variable declaration inside functions.\nvarName := value E.g.:\ni := 10 s := \u0026quot;hello\u0026quot; ok := true When declaring a variable without specifying it\u0026rsquo;s type the variable\u0026rsquo;s type is inferred from the value on the right-hand side.\nvar i int j := i // j is an int i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 Assign or Re-assign\nYou can assign or re-assign value to a declared variable as:\nvarName = value E.g.:\ni = 12 s = \u0026quot;world\u0026quot; ok = false Multiple variable declarations\nMultiple variables of the same type with the single var statement\nvar i, j, k int var x, y, z = 0.867 + 0.5i, 4.65, true Multiple variables of the different types with the single var statement\nvar ( i int = 10 s string = \u0026quot;hello\u0026quot; ok bool = true ) Constants Go supports constants of character, string, boolean, and numeric values. Constants are declared using const keyword.\nE.g:\nconst str string = \u0026quot;constants\u0026quot; Untyped and Typed\nConstants can be declared with or without a type in Go. If we are declaring literal constant, then we are declaring constants that are untyped and unnamed.\nE.g.:\nconst str string = \u0026quot;constants\u0026quot; //Typed constant const i = 10 //Untyped constant, literal declaration const f = 3.14 The constants on the LHS of the declaration are named constants and the literal values on the RHS are unnamed constants.\nTyped constants don’t use the same type system as variables, they\u0026rsquo;ve their implementation for representing the values that we associate with them.\nIn the case of typed constant, the declared type is used to associate the type’s precision limitations or kind of constant.\nIn the case of untyped constant, the literal value will determine what kind/type the constant takes\nEvery GO compiler has the flexibility to implement constant as they wish, within the mandatory set of requirements.\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 First program in Go: Hello World   \u0026emsp; • Contents   \u0026emsp; Looping Construct 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/series/vdc/"
  },{
    "title": "Classic hello world program",
    "date": "",
    "description": "",
    "body": "First thing, packages In Go, source files are organized into system directories called packages, which enable code reusability. When you build reusable pieces of code, you will develop a package as a shared library. But when you develop executable programs, you will use the package main for making the package as an executable program. The package main tells the Go compiler that the package should compile as an executable program instead of a shared library.\npackage main Import The keyword import is used for importing a package into other packages. When you import packages, the Go compiler will look on the locations specified by the environment variable ROOT and PATH.\n// Single pkg/lib import import \u0026quot;fmt\u0026quot; // Multiple pkg/lib import import( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) Main function The main function in the package main will be the entry point of our executable program. When you build shared libraries, you will not have any main package and main function in the package.\nfunc main(){} Hello World package main import \u0026quot;fmt\u0026quot; func main() { fmt.Println(\u0026quot;Hello, World!\u0026quot;) } Save it as main.go or any-name-you-prefer.go\nTo run this program:\ngo run main.go Hello, World! Run this code in Go Playground\nThank you for reading this blog please give your feedback in the comment section below.\n 🡄 Introduction and Installation   \u0026emsp; • Contents   \u0026emsp; Variables, data types and constants 🡆   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference   ",
    "ref": "/blog/golang/series/helloworld/"
  },{
    "title": "Go Introduction and Installation",
    "date": "",
    "description": "",
    "body": "Go is an open-source, statically typed, compiled programing language built by Google. It combines the simplest of both statically typed and dynamically typed languages and provides you with the proper mixture of efficiency and simple programming. It is primarily fitted to building fast, efficient, and reliable server-side or system applications.\nFollowing are some noted features of Go -\n Safety Concurrency Efficient Garbage Collection High-speed compilation Excellent Tooling support  Installing GO Go binary distributions are available for all major operating systems like Linux, Windows, and macOS. It’s easy to install Go from the binary distributions or you can try installing Go from source.\nLinux   Download Go for Linux from Go’s official download page.\ntar -xvf go1.15.6.linux-amd64.tar.gz It will create a directory named go.\n  Move that dir to /usr/local where all other binaries reside.\nexport PATH=$PATH:/usr/local/go/bin   Custom Installation directory\nInstead of moving dir to /usr/local you can choose any other dir.\nmv go $HOME/ Then set this custom location to GOROOT environment variable.\nexport GOROOT=$HOME/go To make GOROOT permanent add it to .bashrc or .zshrc depending on which shell you are using or else your GOROOT will be unset once you end your terminal session or start a new terminal session.\n  MacOS X Install GO in MacOS using Homebrew.\nbrew install go Windows Download the Windows installer from Go’s official download page. Open the installer and follow the on-screen instructions to install Go. By default, the installer installs Go in C:\\Go.\nOnce installed try go version to check the installation.\nGo Code organization  Note: After the introduction of Go modules in Go 1.11, its no longer required to store Go code in the Go workspace. You can create your Go project in any directory outside of GOPATH. You can refer to go docs on code organization. The following Go Code organization is still widely in use mostly because of its elegant organizing structure. \nWorkspace Go requires you to organize your code in a specific way -\nBy convention, all your Go code and the code must reside in a single workspace whose path is stored in the environment variable GOPATH.\nThe workspace dir is supposed to contain the following sub-dir:\n  src: contains Go source files.\nThe src directory typically contains many version control repositories containing one or more Go packages. Every Go source file belongs to a package. You generally create a new subdirectory inside your repository for every separate Go package. The tree for this looks like the following:\ngo └── src └── github.com ├── pratikjagrut │ └── go-tutorial │ └── helloworld │ └── main.go └── user └── project   bin: contains the executable binaries.\nThe Go tool builds and installs executable binaries to this directory.\n  pkg: contains Go package archives.\nAll the non-executable packages (shared libraries) are stored in this directory. This is typically imported and used inside other executable packages.\n  Setting GOPATH Linux and macOS mkdir $HOME/go_workspace export GOPATH=$HOME/go_workspace To make GOPATH permanent add it to .bashrc or .zshrc depending on which shell you are using or else your GOPATH will be unset once you end your terminal session or start a new terminal session.\nWindows System   Create the workspace folder at C:\\go-workspace.\n  Right-click on Start → click Control Panel → Select System and Security → click on System.\n  From the menu on the left, select the Advanced system\u0026rsquo;s settings.\n  Click the Environment Variables button at the bottom.\n  Click New from the User variables section.\n  Type GOPATH into the Variable name field.\n  Type C:\\go-workspace into the Variable value field.\n  Click OK.\n  Note: GOPATH must be different than the path of your Go installation.\nThank you for reading this blog please give your feedback in the comment section below.\n • Contents   \u0026emsp; 🡆 First program in Go: Hello World   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference   ",
    "ref": "/blog/golang/series/introduction/"
  },{
    "title": "Resume",
    "date": "",
    "description": "",
    "body": "PRATIK JAGRUT Bangalore, India  A computer science engineer, an open-source enthusiast and tech speaker with a passion for programming, eager to learn new technologies and desire to work in an environment which encourages learning. I\u0026rsquo;m a goal-oriented individual with a pleasant personality and a tenacity that knows no bounds.\n Experience   Red Hat / ​Software Quality Engineer January 2019 - present, Bangalore, India  Working on a project called ​Service Binding Operator  which is an open source project. My primary focus is to test the quality of the product by adding automated tests and fixing bugs.    Red Hat / ​ Intern June 2018 - January 2019, Pune, India  Worked as an intern on project SSSD(System Security Services Daemon) which is a remote authentication client for Linux based systems. Primary worked to create an automated tests framework based on Pytest to add and write automated tests.    Sheng Li Telecom India Pvt Ltd / ​ Software Engineer Intern November 2017 - April 2018, Pune, India  Worked as a team lead and developer for the office automation project.     Open source Contribution   Tektoncd Cli , the Tekton Pipelines CLI project provides a CLI for interacting with Tekton!   Helm , the helm is a tool for managing packages of pre-configured Kubernetes resources.    Community contribution  Speaker at Paris Open source summit 2019, Speaker Kubernetes and Cloud-native Bangalore meetup. Member of the organizing committee of DevConf INDIA 2018.   Skills   Programming Languages\n Proficient in Golang and Python Prior experience: C++, PHP, TypeScript    Technologies\n Kubernetes, OpenShift, Podman, Linux, Git, Fedora, containers     Certifications   Red Hat Certified Specialist in OpenShift Administration      Red Hat Certified Specialist in OpenShift Application Development      Red Hat Certified Engineer      Red Hat Certified System Administrator     Education   G. H. Raisoni College of Engineering, Nagpur, Maharashtra, India BE. Computer science and Engineering, 2014 - 2018,\nCGPA: 8.73\n  Kulbhushan Jr. College, Aurangabad, Maharashtra, India​ Higher School Secondary Certificate, 2012 - 2014\nPercentage: 79.08%*\n   Awards  Secured 1st position at e-Governance conference for best e-Governance Project model at 19th National e-Governance conference (01/2015). Secured 77th all India rank in IEEEXtreme 11.0, 24 hours coding competition.   Interests  Space science and quantum physics, philosophy, playing around open source projects, travelling, football and swimming.   Human languages  English Hindi Marathi   ",
    "ref": "/resume/"
  },{
    "title": "About Pratik",
    "date": "",
    "description": "",
    "body": "Pratik currently works at Red Hat as Associate Software Engineer since January 2019. He joined Red Hat as an intern just after graduating in 2018. He holds a Bachelor of Engineering degree in Computer Science.\nPratik is enthusiastic about Linux and opensource technologies. He\u0026rsquo;s fueled by his passion for understanding new technologies. He considers himself a ‘forever student', eager to learn, grow and build his professional and personal life.\nPratik is also very enamoured of outdoor activities. He likes to play European football, swimming, trekking and travelling around the globe.\nClick here to know more about him.\nReach me @      Github  \u0026emsp; Twitter  \u0026emsp; Linkedin  \u0026emsp; Facebook  \u0026emsp; Email --  ",
    "ref": "/about/"
  }]
