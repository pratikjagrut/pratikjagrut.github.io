[{
    "title": "Golang",
    "date": "",
    "description": "Index page",
    "body": "Contents Github Repo   \u0026emsp; \u0026#128279; Reference     Introduction and Installation  \u0026emsp;   First program in Go: Hello World  \u0026emsp;   Variables, data types and constants  \u0026emsp;   Looping Construct  \u0026emsp;   Conditional Statements  \u0026emsp;   Switch Statement  \u0026emsp;   Arrays and Slices  \u0026emsp;  ",
    "ref": "/blog/golang/contents/"
  },{
    "title": "Arrays and Slices",
    "date": "",
    "description": "",
    "body": "Array The array is a collection of the same type of element in a contiguous memory location. The array has fixed length i.e the number of elements to be stored is fixed before memory allocation.\nIn Go, the type [n]T is an array of length n and type T.\nArray Declarations // i is an array of length 3, // it means it can hold upto 3 int values var i [3]int i[0] = 1 i[1] = 10 i[2] = 100 Short-hand declaration\nj := [3]string{\u0026quot;Go\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;fun\u0026quot;} You can refer main.go file for arrays examples\nSlices Slices are a pivotal data type in Go, giving a more powerful interface to sequences than arrays. An array has a fixed size whereas the slice is a dynamically-sized.\nThe type []T is a slice with elements of type T.\nSlice formation Creating a slice with make Slices can be created with the built-in make function; this is how you create dynamically-sized arrays. make([]T, len, cap(optional))\na := make([]int, 5) // len(a) = 5 b := make([]int, 0, 5) // len(b) = 0, cap(b) = 5 Creating a slice from array Slice can be formed by specifying 2 indices, high bound and low bound, s[low : high]. This selects a half-open range which includes the first element but excludes the last one.\nodds := [5]int{1, 3, 5, 7, 9} var o []int = odds[1:4] We can skip low or high bound to use their defaults. For low bound default is 0 and for high bound default is length of an array.\na[:high], a[low:]\nSlice are like references to arrays A slice does not store any data, it just describes a section of an underlying array.\nChanging element of the slice will make those changes to an underlying array and all other slices which share the same underlying array.\nalphabet := [5]string{\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;D\u0026quot;} i := alphabet[0:3] j := alphabet[1:4] i[2] = \u0026quot;P\u0026quot; // This changes will affect alphabet, i ,j slices Slice literals A slice literal is like an array literal without the length.\ni := []int{1, 2, 3, 4, 5,} Length and capacity The length of a slice is the number of elements it contains.\nThe capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.\nLength: len(s)\nCapacity: cap(s)\nAppending Slices support several operations including basic operations of arrays. One of such operation is appending.\nz := []int{1, 2, 3, 4, 5} z = append(z, 6, 7, 8) //1st arg is slice, and then can take any number of arg to append You can refer main.go file for slices examples\n ðŸ¡„ Switch Statement   \u0026emsp; â€¢ Contents   \u0026emsp;  ðŸ¡†   \u0026emsp; -- Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/array_slice/"
  },{
    "title": "Switch",
    "date": "",
    "description": "",
    "body": "A switch statement is another way to write a sequence of if - else statements.\nGo\u0026rsquo;s switch is like the one in C and C++ except that it only runs the selected case, not all the cases that follows so we don\u0026rsquo;t need break statement here.\nswitch expression { case exp1: //Executes if expression matches exp1 case exp2: //Executes if expression matches exp2 default: //Executes if expression does not matches with any case } Switch evaluation order Switch cases evaluate cases from top to bottom and stops when a case succeeds.\nIn below example, it checks case \u0026quot;Linux\u0026quot;: if os matches with Linux then it stops at that case else go to the next case.\n//Prints which OS you're using switch os := runtime.GOOS; os { case \u0026quot;linux\u0026quot;: fmt.Println(\u0026quot;Linux.\u0026quot;) case \u0026quot;darwin\u0026quot;: fmt.Println(\u0026quot;OS X.\u0026quot;) default: fmt.Printf(\u0026quot;%s.\\n\u0026quot;, os) } Switch with NO condition Switch with no condition is like switch true. It is useful for writing log if-else-if ladder.\nt := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026quot;Good morning!\u0026quot;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026quot;Good afternoon.\u0026quot;) default: fmt.Println(\u0026quot;Good evening.\u0026quot;) } You can refer main.go file for examples\n ðŸ¡„ Conditional Statements   \u0026emsp; â€¢ Contents   \u0026emsp; Arrays and Slices ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/switch/"
  },{
    "title": "Conditional Statements",
    "date": "",
    "description": "",
    "body": "Conditional Statements are part of every programming language. They help us to decide which instruction is suppose to run when certain condition is met. e.g. If I\u0026rsquo;m hungry then I\u0026rsquo;ll eat else I\u0026rsquo;ll wait. e.g. If score is greater than 35%, you passed, else you failed.\nIf statement in Go if condition/expression { //instruction to be performed } Condition needs to be true to perform the given set of instructions.\npackage main import \u0026quot;fmt\u0026quot; func main(){ i := 10 if i % 2 == 0 { fmt.Printf(\u0026quot;%d is a even number\u0026quot;, i) } } If-Else statement in Go if condition/expression { //instruction to be performed } else { //instruction to be performed } If condition need to be false to perform instruction from else block.\npackage main import \u0026quot;fmt\u0026quot; func main(){ i := 11 if i % 2 == 0 { fmt.Printf(\u0026quot;%d is a even number\u0026quot;, i) } else { fmt.Printf(\u0026quot;%d is a odd number\u0026quot;, i) } } if-else-if ladder We can use multiple conditional statement at once which.\nif i == 0 { fmt.Println(\u0026quot;It's zero\u0026quot;) } else if i \u0026lt; 0 { fmt.Println(\u0026quot;Negative number\u0026quot;) } else { fmt.Println(\u0026quot;Positive number\u0026quot;) } If with a short statement if j := 10; j%2 == 0 { fmt.Println(\u0026quot;Even number\u0026quot;) } You can refer main.go file for examples\n ðŸ¡„ Looping Construct   \u0026emsp; â€¢ Contents   \u0026emsp; Switch Statement ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/if_else/"
  },{
    "title": "Looping Construct",
    "date": "",
    "description": "",
    "body": "Go has only one looping construct, the for loop.\nBasic for loop The basic for loop has three components separated by semicolons:\n init statement: i := 0 exec before 1st iteration condition expression: i \u0026lt; n eval on every interation post statement: i++ exec after each iteration  The expression is not surrounded by parentheses ( ) but the braces { } around set of instructions are required.\nfor i := 0; i \u0026lt; n; i++ { //business logic //set of instructions } Init and post statement are optional.\nfor ; i \u0026lt; n; { //business logic } For is also a while() loop for i \u0026lt; n { //business logic } Infinite loop for { //business logic } Example package main import \u0026quot;fmt\u0026quot; func main() { for i := 0; i \u0026lt; 5; i++ {fmt.Printf(\u0026quot;Iteration number: %d\\n\u0026quot;, i)} } go run main.go Iteration number: 0 Iteration number: 1 Iteration number: 2 Iteration number: 3 Iteration number: 4 You can refer main.go file for examples\n ðŸ¡„ Variables, data types and constants   \u0026emsp; â€¢ Contents   \u0026emsp; Conditional Statements ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/for_loop/"
  },{
    "title": "Variables, data types and constants",
    "date": "",
    "description": "",
    "body": "Variable Variable is a symbolic name given to the storage location which contains some value which can be changed at any time during the execution of the program. A variable must be defined with the type of data or value it is holding.\nData types There are several data types in Go.\nbool int uint float32 complex64 string int8 uint8 float64 complex128 byte int16 uint16 rune int32 uint32 error int64 uint64 Zero value In some programming languages variable holds a null or undefined value when not initialized, Go gives it a zero-value of its data type. A boolean variable if not initialized, gets the false value and an integer variable gets 0 value, string variable will get nil value.\nDeclaring a variable The var statement declares a list of variables. Type is at the last of the statement.\nvar varName dataType E.g.:\nvar i, j, k int var f float32 var u uint Variables with initializers\nWe can initialize variable while declaring.\nvar varName dataType = value var i int = 10 var s string = \u0026quot;hello\u0026quot; var ok bool = true We can omit the type of variable, it will take the type of initializers\nvar i = 42 // int var f = 3.142 // float64 var g = \u0026quot;hello\u0026quot; // string Short-hand declaration\nThis is the most commonly used variable declaration inside functions.\nvarName := value E.g.:\ni := 10 s := \u0026quot;hello\u0026quot; ok := true When declaring a variable without specifying it\u0026rsquo;s type the variable\u0026rsquo;s type is inferred from the value on the right-hand side.\nvar i int j := i // j is an int i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 Assign or Re-assign\nYou can assign or re-assign value to a declared variable as:\nvarName = value E.g.:\ni = 12 s = \u0026quot;world\u0026quot; ok = false Multiple variable declarations\nMultiple variables of the same type with the single var statement\nvar i, j, k int var x, y, z = 0.867 + 0.5i, 4.65, true Multiple variables of the different types with the single var statement\nvar ( i int = 10 s string = \u0026quot;hello\u0026quot; ok bool = true ) Constants Go supports constants of character, string, boolean, and numeric values. Constants are declared using const keyword.\nE.g:\nconst str string = \u0026quot;constants\u0026quot; Untyped and Typed\nConstants can be declared with or without a type in Go. If we are declaring literal constant, then we are declaring constants that are untyped and unnamed.\nE.g.:\nconst str string = \u0026quot;constants\u0026quot; //Typed constant const i = 10 //Untyped constant, literal declaration const f = 3.14 The constants on the LHS of the declaration are named constants and the literal values on the RHS are unnamed constants.\nTyped constants donâ€™t use the same type system as variables, they\u0026rsquo;ve their implementation for representing the values that we associate with them.\nIn the case of typed constant, the declared type is used to associate the typeâ€™s precision limitations or kind of constant.\nIn the case of untyped constant, the literal value will determine what kind/type the constant takes\nEvery GO compiler has the flexibility to implement constant as they wish, within the mandatory set of requirements.\nYou can refer main.go file for examples\n ðŸ¡„ First program in Go: Hello World   \u0026emsp; â€¢ Contents   \u0026emsp; Looping Construct ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference  ",
    "ref": "/blog/golang/vdc/"
  },{
    "title": "Classic hello world program",
    "date": "",
    "description": "",
    "body": "First thing, packages In Go, source files are organized into system directories called packages, which enable code reusability. When you build reusable pieces of code, you will develop a package as a shared library. But when you develop executable programs, you will use the package main for making the package as an executable program. The package main tells the Go compiler that the package should compile as an executable program instead of a shared library.\npackage main Import The keyword import is used for importing a package into other packages. When you import packages, the Go compiler will look on the locations specified by the environment variable ROOT and PATH.\n// Single pkg/lib import import \u0026quot;fmt\u0026quot; // Multiple pkg/lib import import( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) Main function The main function in the package main will be the entry point of our executable program. When you build shared libraries, you will not have any main package and main function in the package.\nfunc main(){} Hello World package main import \u0026quot;fmt\u0026quot; func main() { fmt.Println(\u0026quot;Hello, World!\u0026quot;) } Save it as main.go or any-name-you-prefer.go\nTo run this program:\ngo run main.go Hello, World!  ðŸ¡„ Introduction and Installation   \u0026emsp; â€¢ Contents   \u0026emsp; Variables, data types and constants ðŸ¡†   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference   ",
    "ref": "/blog/golang/helloworld/"
  },{
    "title": "Go Introduction and Installation",
    "date": "",
    "description": "",
    "body": "Go is an open-source, statically typed, compiled programing language built by Google. It combines the simplest of both statically typed and dynamically typed languages and provides you with the proper mixture of efficiency and simple programming. It is primarily fitted to building fast, efficient, and reliable server-side or system applications.\nFollowing are some noted features of Go -\n Safety Concurrency Efficient Garbage Collection High-speed compilation Excellent Tooling support  Installing GO Go binary distributions are available for all major operating systems like Linux, Windows, and macOS. Itâ€™s easy to install Go from the binary distributions or you can try installing Go from source.\nLinux   Download Go for Linux from Goâ€™s official download page.\ntar -xvf go1.15.6.linux-amd64.tar.gz It will create a directory named go.\n  Move that dir to /usr/local where all other binaries reside.\nexport PATH=$PATH:/usr/local/go/bin   Custom Installation directory\nInstead of moving dir to /usr/local you can choose any other dir.\nmv go $HOME/ Then set this custom location to GOROOT environment variable.\nexport GOROOT=$HOME/go To make GOROOT permanent add it to .bashrc or .zshrc depending on which shell you are using or else your GOROOT will be unset once you end your terminal session or start a new terminal session.\n  MacOS X Install GO in MacOS using Homebrew.\nbrew install go Windows Download the Windows installer from Goâ€™s official download page. Open the installer and follow the on-screen instructions to install Go. By default, the installer installs Go in C:\\Go.\nOnce installed try go version to check the installation.\nGo Code organization  Note: After the introduction of Go modules in Go 1.11, its no longer required to store Go code in the Go workspace. You can create your Go project in any directory outside of GOPATH. You can refer to go docs on code organization. The following Go Code organization is still widely in use mostly because of its elegant organizing structure. \nWorkspace Go requires you to organize your code in a specific way -\nBy convention, all your Go code and the code must reside in a single workspace whose path is stored in the environment variable GOPATH.\nThe workspace dir is supposed to contain the following sub-dir:\n  src: contains Go source files.\nThe src directory typically contains many version control repositories containing one or more Go packages. Every Go source file belongs to a package. You generally create a new subdirectory inside your repository for every separate Go package. The tree for this looks like the following:\ngo â””â”€â”€ src â””â”€â”€ github.com â”œâ”€â”€ pratikjagrut â”‚ â””â”€â”€ go-tutorial â”‚ â””â”€â”€ helloworld â”‚ â””â”€â”€ main.go â””â”€â”€ user â””â”€â”€ project   bin: contains the executable binaries.\nThe Go tool builds and installs executable binaries to this directory.\n  pkg: contains Go package archives.\nAll the non-executable packages (shared libraries) are stored in this directory. This is typically imported and used inside other executable packages.\n  Setting GOPATH Linux and macOS mkdir $HOME/go_workspace export GOPATH=$HOME/go_workspace To make GOPATH permanent add it to .bashrc or .zshrc depending on which shell you are using or else your GOPATH will be unset once you end your terminal session or start a new terminal session.\nWindows System   Create the workspace folder at C:\\go-workspace.\n  Right-click on Start â†’ click Control Panel â†’ Select System and Security â†’ click on System.\n  From the menu on the left, select the Advanced system\u0026rsquo;s settings.\n  Click the Environment Variables button at the bottom.\n  Click New from the User variables section.\n  Type GOPATH into the Variable name field.\n  Type C:\\go-workspace into the Variable value field.\n  Click OK.\n  Note: GOPATH must be different than the path of your Go installation.\n â€¢ Contents   \u0026emsp; ðŸ¡† First program in Go: Hello World   \u0026emsp; Github Repo   \u0026emsp; \u0026#128279; Reference   ",
    "ref": "/blog/golang/introduction/"
  },{
    "title": "Resume",
    "date": "",
    "description": "",
    "body": "PRATIK JAGRUT Bangalore, India  A computer science engineer, an open-source enthusiast and tech speaker with a passion for programming, eager to learn new technologies and desire to work in an environment which encourages learning. I\u0026rsquo;m a goal-oriented individual with a pleasant personality and a tenacity that knows no bounds.\n Experience   Red Hat / â€‹ Associate Software Engineer January 2019 - present, Bangalore, India  Working on a project called â€‹Service Binding Operator  which is an open source project. My primary focus is to test the quality of the product by adding automated tests and fixing bugs.    Red Hat / â€‹ Intern June 2018 - January 2019, Pune, India  Worked as an intern on project SSSD(System Security Services Daemon) which is a remote authentication client for Linux based systems. Primary worked to create an automated tests framework based on Pytest to add and write automated tests.    Sheng Li Telecom India Pvt Ltd / â€‹ Software Engineer Intern November 2017 - April 2018, Pune, India  Worked as a team lead and developer for the office automation project.     Open source Contribution   Tektoncd Cli , the Tekton Pipelines CLI project provides a CLI for interacting with Tekton!   Helm , the helm is a tool for managing packages of pre-configured Kubernetes resources.    Community contribution  Speaker at Paris Open source summit 2019, Speaker Kubernetes and Cloud-native Bangalore meetup. Member of the organizing committee of DevConf INDIA 2018.   Skills   Programming Languages\n Proficient in Golang and Python Prior experience: C++, PHP, TypeScript    Technologies\n Kubernetes, OpenShift, Podman, Linux, Git, Fedora, containers     Certifications   Red Hat Certified Specialist in OpenShift Administration      Red Hat Certified Specialist in OpenShift Application Development      Red Hat Certified Engineer      Red Hat Certified System Administrator     Education   G. H. Raisoni College of Engineering, Nagpur, Maharashtra, India BE. Computer science and Engineering, 2014 - 2018,\nCGPA: 8.73\n  Kulbhushan Jr. College, Aurangabad, Maharashtra, Indiaâ€‹ Higher School Secondary Certificate, 2012 - 2014\nPercentage: 79.08%*\n   Awards  Secured 1st position at e-Governance conference for best e-Governance Project model at 19th National e-Governance conference (01/2015). Secured 77th all India rank in IEEEXtreme 11.0, 24 hours coding competition.   Interests  Space science and quantum physics, philosophy, playing around open source projects, travelling, football and swimming.   Human languages  English Hindi Marathi   ",
    "ref": "/resume/"
  },{
    "title": "About Pratik",
    "date": "",
    "description": "",
    "body": "Pratik currently works at Red Hat as Associate Software Engineer since January 2019. He joined Red Hat as an intern just after graduating in 2018. He holds a Bachelor of Engineering degree in Computer Science.\nPratik is enthusiastic about Linux and opensource technologies. He\u0026rsquo;s fueled by his passion for understanding new technologies. He considers himself a â€˜forever student', eager to learn, grow and build his professional and personal life.\nPratik is also very enamoured of outdoor activities. He likes to play European football, swimming, trekking and travelling around the globe.\nClick here to know more about him.\nGithub  \u0026emsp; Twitter  \u0026emsp; Linkedin  \u0026emsp; Facebook  \u0026emsp; Email  ",
    "ref": "/about/"
  }]
